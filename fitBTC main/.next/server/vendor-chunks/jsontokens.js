"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsontokens";
exports.ids = ["vendor-chunks/jsontokens"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsontokens/lib/base64Url.js":
/*!**************************************************!*\
  !*** ./node_modules/jsontokens/lib/base64Url.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = exports.unescape = exports.escape = exports.pad = void 0;\nconst base64_js_1 = __webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/base64-js/index.js\");\nfunction pad(base64) {\n    return `${base64}${'='.repeat(4 - (base64.length % 4 || 4))}`;\n}\nexports.pad = pad;\nfunction escape(base64) {\n    return base64.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nexports.escape = escape;\nfunction unescape(base64Url) {\n    return pad(base64Url).replace(/-/g, '+').replace(/_/g, '/');\n}\nexports.unescape = unescape;\nfunction encode(base64) {\n    return escape((0, base64_js_1.fromByteArray)(new TextEncoder().encode(base64)));\n}\nexports.encode = encode;\nfunction decode(base64Url) {\n    return new TextDecoder().decode((0, base64_js_1.toByteArray)(pad(unescape(base64Url))));\n}\nexports.decode = decode;\n//# sourceMappingURL=base64Url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvYmFzZTY0VXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLFdBQVc7QUFDakYsb0JBQW9CLG1CQUFPLENBQUMsMERBQVc7QUFDdkM7QUFDQSxjQUFjLE9BQU8sRUFBRSx5Q0FBeUM7QUFDaEU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJDOlxcTmFtYW4gU2luZ2h2aSBQZXJzb25hbFxcSGFydmFyZCBIYWNrYXRob25cXGZpdEJUQ1xcZml0QlRDIG1haW5cXG5vZGVfbW9kdWxlc1xcanNvbnRva2Vuc1xcbGliXFxiYXNlNjRVcmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy51bmVzY2FwZSA9IGV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5wYWQgPSB2b2lkIDA7XG5jb25zdCBiYXNlNjRfanNfMSA9IHJlcXVpcmUoXCJiYXNlNjQtanNcIik7XG5mdW5jdGlvbiBwYWQoYmFzZTY0KSB7XG4gICAgcmV0dXJuIGAke2Jhc2U2NH0keyc9Jy5yZXBlYXQoNCAtIChiYXNlNjQubGVuZ3RoICUgNCB8fCA0KSl9YDtcbn1cbmV4cG9ydHMucGFkID0gcGFkO1xuZnVuY3Rpb24gZXNjYXBlKGJhc2U2NCkge1xuICAgIHJldHVybiBiYXNlNjQucmVwbGFjZSgvPS9nLCAnJykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbmZ1bmN0aW9uIHVuZXNjYXBlKGJhc2U2NFVybCkge1xuICAgIHJldHVybiBwYWQoYmFzZTY0VXJsKS5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xufVxuZXhwb3J0cy51bmVzY2FwZSA9IHVuZXNjYXBlO1xuZnVuY3Rpb24gZW5jb2RlKGJhc2U2NCkge1xuICAgIHJldHVybiBlc2NhcGUoKDAsIGJhc2U2NF9qc18xLmZyb21CeXRlQXJyYXkpKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShiYXNlNjQpKSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShiYXNlNjRVcmwpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKCgwLCBiYXNlNjRfanNfMS50b0J5dGVBcnJheSkocGFkKHVuZXNjYXBlKGJhc2U2NFVybCkpKSk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NFVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/base64Url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/cryptoClients/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jsontokens/lib/cryptoClients/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cryptoClients = exports.SECP256K1Client = void 0;\nconst secp256k1_1 = __webpack_require__(/*! ./secp256k1 */ \"(ssr)/./node_modules/jsontokens/lib/cryptoClients/secp256k1.js\");\nObject.defineProperty(exports, \"SECP256K1Client\", ({ enumerable: true, get: function () { return secp256k1_1.SECP256K1Client; } }));\nconst cryptoClients = {\n    ES256K: secp256k1_1.SECP256K1Client,\n};\nexports.cryptoClients = cryptoClients;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvY3J5cHRvQ2xpZW50cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyx1QkFBdUI7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsbUZBQWE7QUFDekMsbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiQzpcXE5hbWFuIFNpbmdodmkgUGVyc29uYWxcXEhhcnZhcmQgSGFja2F0aG9uXFxmaXRCVENcXGZpdEJUQyBtYWluXFxub2RlX21vZHVsZXNcXGpzb250b2tlbnNcXGxpYlxcY3J5cHRvQ2xpZW50c1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0b0NsaWVudHMgPSBleHBvcnRzLlNFQ1AyNTZLMUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIi4vc2VjcDI1NmsxXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU0VDUDI1NksxQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWNwMjU2azFfMS5TRUNQMjU2SzFDbGllbnQ7IH0gfSk7XG5jb25zdCBjcnlwdG9DbGllbnRzID0ge1xuICAgIEVTMjU2Szogc2VjcDI1NmsxXzEuU0VDUDI1NksxQ2xpZW50LFxufTtcbmV4cG9ydHMuY3J5cHRvQ2xpZW50cyA9IGNyeXB0b0NsaWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/cryptoClients/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/cryptoClients/secp256k1.js":
/*!****************************************************************!*\
  !*** ./node_modules/jsontokens/lib/cryptoClients/secp256k1.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SECP256K1Client = void 0;\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/hmac.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst secp = __webpack_require__(/*! @noble/secp256k1 */ \"(ssr)/./node_modules/@noble/secp256k1/lib/index.js\");\nconst ecdsaSigFormatter_1 = __webpack_require__(/*! ../ecdsaSigFormatter */ \"(ssr)/./node_modules/jsontokens/lib/ecdsaSigFormatter.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/jsontokens/lib/errors.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n// required to use noble secp https://github.com/paulmillr/noble-secp256k1\nsecp.utils.hmacSha256Sync = (key, ...msgs) => {\n    const h = hmac_1.hmac.create(sha256_1.sha256, key);\n    msgs.forEach(msg => h.update(msg));\n    return h.digest();\n};\nclass SECP256K1Client {\n    static derivePublicKey(privateKey, compressed = true) {\n        if (privateKey.length === 66) {\n            privateKey = privateKey.slice(0, 64);\n        }\n        if (privateKey.length < 64) {\n            // backward compatibly accept too short private keys\n            privateKey = privateKey.padStart(64, '0');\n        }\n        return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));\n    }\n    static signHash(signingInputHash, privateKey, format = 'jose') {\n        // make sure the required parameters are provided\n        if (!signingInputHash || !privateKey) {\n            throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n        }\n        const derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {\n            der: true,\n            canonical: false,\n        });\n        if (format === 'der')\n            return (0, utils_1.bytesToHex)(derSignature);\n        if (format === 'jose')\n            return (0, ecdsaSigFormatter_1.derToJose)(derSignature, 'ES256');\n        throw Error('Invalid signature format');\n    }\n    static loadSignature(joseSignature) {\n        // create and return the DER-formatted signature bytes\n        return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, 'ES256');\n    }\n    static verifyHash(signingInputHash, derSignatureBytes, publicKey) {\n        // make sure the required parameters are provided\n        if (!signingInputHash || !derSignatureBytes || !publicKey) {\n            throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n        }\n        return secp.verify(derSignatureBytes, signingInputHash, publicKey, { strict: false });\n    }\n}\nexports.SECP256K1Client = SECP256K1Client;\nSECP256K1Client.algorithmName = 'ES256K';\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvY3J5cHRvQ2xpZW50cy9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDdkMsNEJBQTRCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLGdFQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxOYW1hbiBTaW5naHZpIFBlcnNvbmFsXFxIYXJ2YXJkIEhhY2thdGhvblxcZml0QlRDXFxmaXRCVEMgbWFpblxcbm9kZV9tb2R1bGVzXFxqc29udG9rZW5zXFxsaWJcXGNyeXB0b0NsaWVudHNcXHNlY3AyNTZrMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0VDUDI1NksxQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgaG1hY18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hY1wiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3Qgc2VjcCA9IHJlcXVpcmUoXCJAbm9ibGUvc2VjcDI1NmsxXCIpO1xuY29uc3QgZWNkc2FTaWdGb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuLi9lY2RzYVNpZ0Zvcm1hdHRlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbi8vIHJlcXVpcmVkIHRvIHVzZSBub2JsZSBzZWNwIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxXG5zZWNwLnV0aWxzLmhtYWNTaGEyNTZTeW5jID0gKGtleSwgLi4ubXNncykgPT4ge1xuICAgIGNvbnN0IGggPSBobWFjXzEuaG1hYy5jcmVhdGUoc2hhMjU2XzEuc2hhMjU2LCBrZXkpO1xuICAgIG1zZ3MuZm9yRWFjaChtc2cgPT4gaC51cGRhdGUobXNnKSk7XG4gICAgcmV0dXJuIGguZGlnZXN0KCk7XG59O1xuY2xhc3MgU0VDUDI1NksxQ2xpZW50IHtcbiAgICBzdGF0aWMgZGVyaXZlUHVibGljS2V5KHByaXZhdGVLZXksIGNvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjYpIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5LnNsaWNlKDAsIDY0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggPCA2NCkge1xuICAgICAgICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJseSBhY2NlcHQgdG9vIHNob3J0IHByaXZhdGUga2V5c1xuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXkucGFkU3RhcnQoNjQsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKHNlY3AuZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGNvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgc3RhdGljIHNpZ25IYXNoKHNpZ25pbmdJbnB1dEhhc2gsIHByaXZhdGVLZXksIGZvcm1hdCA9ICdqb3NlJykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkXG4gICAgICAgIGlmICghc2lnbmluZ0lucHV0SGFzaCB8fCAhcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk1pc3NpbmdQYXJhbWV0ZXJzRXJyb3IoJ2Egc2lnbmluZyBpbnB1dCBoYXNoIGFuZCBwcml2YXRlIGtleSBhcmUgYWxsIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVyU2lnbmF0dXJlID0gc2VjcC5zaWduU3luYyhzaWduaW5nSW5wdXRIYXNoLCBwcml2YXRlS2V5LnNsaWNlKDAsIDY0KSwge1xuICAgICAgICAgICAgZGVyOiB0cnVlLFxuICAgICAgICAgICAgY2Fub25pY2FsOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZXInKVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGRlclNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqb3NlJylcbiAgICAgICAgICAgIHJldHVybiAoMCwgZWNkc2FTaWdGb3JtYXR0ZXJfMS5kZXJUb0pvc2UpKGRlclNpZ25hdHVyZSwgJ0VTMjU2Jyk7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmb3JtYXQnKTtcbiAgICB9XG4gICAgc3RhdGljIGxvYWRTaWduYXR1cmUoam9zZVNpZ25hdHVyZSkge1xuICAgICAgICAvLyBjcmVhdGUgYW5kIHJldHVybiB0aGUgREVSLWZvcm1hdHRlZCBzaWduYXR1cmUgYnl0ZXNcbiAgICAgICAgcmV0dXJuICgwLCBlY2RzYVNpZ0Zvcm1hdHRlcl8xLmpvc2VUb0Rlcikoam9zZVNpZ25hdHVyZSwgJ0VTMjU2Jyk7XG4gICAgfVxuICAgIHN0YXRpYyB2ZXJpZnlIYXNoKHNpZ25pbmdJbnB1dEhhc2gsIGRlclNpZ25hdHVyZUJ5dGVzLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZFxuICAgICAgICBpZiAoIXNpZ25pbmdJbnB1dEhhc2ggfHwgIWRlclNpZ25hdHVyZUJ5dGVzIHx8ICFwdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5NaXNzaW5nUGFyYW1ldGVyc0Vycm9yKCdhIHNpZ25pbmcgaW5wdXQgaGFzaCwgZGVyIHNpZ25hdHVyZSwgYW5kIHB1YmxpYyBrZXkgYXJlIGFsbCByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWNwLnZlcmlmeShkZXJTaWduYXR1cmVCeXRlcywgc2lnbmluZ0lucHV0SGFzaCwgcHVibGljS2V5LCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TRUNQMjU2SzFDbGllbnQgPSBTRUNQMjU2SzFDbGllbnQ7XG5TRUNQMjU2SzFDbGllbnQuYWxnb3JpdGhtTmFtZSA9ICdFUzI1NksnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/cryptoClients/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/cryptoClients/sha256.js":
/*!*************************************************************!*\
  !*** ./node_modules/jsontokens/lib/cryptoClients/sha256.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashSha256Async = exports.hashSha256 = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nfunction hashSha256(input) {\n    return (0, sha256_1.sha256)(input);\n}\nexports.hashSha256 = hashSha256;\nfunction hashSha256Async(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const isSubtleCryptoAvailable = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';\n            if (isSubtleCryptoAvailable) {\n                // Use the W3C Web Crypto API if available (running in a web browser).\n                const bytes = typeof input === 'string' ? new TextEncoder().encode(input) : input;\n                const hash = yield crypto.subtle.digest('SHA-256', bytes);\n                return new Uint8Array(hash);\n            }\n            else {\n                // Otherwise try loading the Node.js `crypto` module (running in Node.js, or an older browser with a polyfill).\n                const nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\n                if (!nodeCrypto.createHash) {\n                    throw new Error('`crypto` module does not contain `createHash`');\n                }\n                return Promise.resolve(nodeCrypto.createHash('sha256').update(input).digest());\n            }\n        }\n        catch (error) {\n            console.log(error);\n            console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, ' +\n                'nor the or the Node.js `require(\"crypto\").createHash` module is available. ' +\n                'Falling back to JS implementation.');\n            return Promise.resolve(hashSha256(input));\n        }\n    });\n}\nexports.hashSha256Async = hashSha256Async;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvY3J5cHRvQ2xpZW50cy9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGtCQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBTyxDQUFDLHNCQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJDOlxcTmFtYW4gU2luZ2h2aSBQZXJzb25hbFxcSGFydmFyZCBIYWNrYXRob25cXGZpdEJUQ1xcZml0QlRDIG1haW5cXG5vZGVfbW9kdWxlc1xcanNvbnRva2Vuc1xcbGliXFxjcnlwdG9DbGllbnRzXFxzaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFNoYTI1NkFzeW5jID0gZXhwb3J0cy5oYXNoU2hhMjU2ID0gdm9pZCAwO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5mdW5jdGlvbiBoYXNoU2hhMjU2KGlucHV0KSB7XG4gICAgcmV0dXJuICgwLCBzaGEyNTZfMS5zaGEyNTYpKGlucHV0KTtcbn1cbmV4cG9ydHMuaGFzaFNoYTI1NiA9IGhhc2hTaGEyNTY7XG5mdW5jdGlvbiBoYXNoU2hhMjU2QXN5bmMoaW5wdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNTdWJ0bGVDcnlwdG9BdmFpbGFibGUgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAoaXNTdWJ0bGVDcnlwdG9BdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIFczQyBXZWIgQ3J5cHRvIEFQSSBpZiBhdmFpbGFibGUgKHJ1bm5pbmcgaW4gYSB3ZWIgYnJvd3NlcikuXG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGlucHV0KSA6IGlucHV0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGJ5dGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdHJ5IGxvYWRpbmcgdGhlIE5vZGUuanMgYGNyeXB0b2AgbW9kdWxlIChydW5uaW5nIGluIE5vZGUuanMsIG9yIGFuIG9sZGVyIGJyb3dzZXIgd2l0aCBhIHBvbHlmaWxsKS5cbiAgICAgICAgICAgICAgICBjb25zdCBub2RlQ3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlQ3J5cHRvLmNyZWF0ZUhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgY3J5cHRvYCBtb2R1bGUgZG9lcyBub3QgY29udGFpbiBgY3JlYXRlSGFzaGAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShub2RlQ3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NyeXB0byBsaWIgbm90IGZvdW5kLiBOZWl0aGVyIHRoZSBnbG9iYWwgYGNyeXB0by5zdWJ0bGVgIFdlYiBDcnlwdG8gQVBJLCAnICtcbiAgICAgICAgICAgICAgICAnbm9yIHRoZSBvciB0aGUgTm9kZS5qcyBgcmVxdWlyZShcImNyeXB0b1wiKS5jcmVhdGVIYXNoYCBtb2R1bGUgaXMgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAgICAgICAnRmFsbGluZyBiYWNrIHRvIEpTIGltcGxlbWVudGF0aW9uLicpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoYXNoU2hhMjU2KGlucHV0KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFzaFNoYTI1NkFzeW5jID0gaGFzaFNoYTI1NkFzeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/cryptoClients/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/decode.js":
/*!***********************************************!*\
  !*** ./node_modules/jsontokens/lib/decode.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeToken = void 0;\nconst base64url = __webpack_require__(/*! ./base64Url */ \"(ssr)/./node_modules/jsontokens/lib/base64Url.js\");\nfunction decodeToken(token) {\n    if (typeof token === 'string') {\n        // decompose the token into parts\n        const tokenParts = token.split('.');\n        const header = JSON.parse(base64url.decode(tokenParts[0]));\n        const payload = JSON.parse(base64url.decode(tokenParts[1]));\n        const signature = tokenParts[2];\n        // return the token object\n        return {\n            header: header,\n            payload: payload,\n            signature: signature,\n        };\n    }\n    else if (typeof token === 'object') {\n        if (typeof token.payload !== 'string') {\n            throw new Error('Expected token payload to be a base64 or json string');\n        }\n        let payload = token.payload;\n        if (token.payload[0] !== '{') {\n            payload = base64url.decode(payload);\n        }\n        const allHeaders = [];\n        token.header.map((headerValue) => {\n            const header = JSON.parse(base64url.decode(headerValue));\n            allHeaders.push(header);\n        });\n        return {\n            header: allHeaders,\n            payload: JSON.parse(payload),\n            signature: token.signature,\n        };\n    }\n}\nexports.decodeToken = decodeToken;\n//# sourceMappingURL=decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvZGVjb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIkM6XFxOYW1hbiBTaW5naHZpIFBlcnNvbmFsXFxIYXJ2YXJkIEhhY2thdGhvblxcZml0QlRDXFxmaXRCVEMgbWFpblxcbm9kZV9tb2R1bGVzXFxqc29udG9rZW5zXFxsaWJcXGRlY29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlVG9rZW4gPSB2b2lkIDA7XG5jb25zdCBiYXNlNjR1cmwgPSByZXF1aXJlKFwiLi9iYXNlNjRVcmxcIik7XG5mdW5jdGlvbiBkZWNvZGVUb2tlbih0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGRlY29tcG9zZSB0aGUgdG9rZW4gaW50byBwYXJ0c1xuICAgICAgICBjb25zdCB0b2tlblBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHRva2VuUGFydHNbMF0pKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZSh0b2tlblBhcnRzWzFdKSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRva2VuUGFydHNbMl07XG4gICAgICAgIC8vIHJldHVybiB0aGUgdG9rZW4gb2JqZWN0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuLnBheWxvYWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRva2VuIHBheWxvYWQgdG8gYmUgYSBiYXNlNjQgb3IganNvbiBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF5bG9hZCA9IHRva2VuLnBheWxvYWQ7XG4gICAgICAgIGlmICh0b2tlbi5wYXlsb2FkWzBdICE9PSAneycpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBiYXNlNjR1cmwuZGVjb2RlKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbEhlYWRlcnMgPSBbXTtcbiAgICAgICAgdG9rZW4uaGVhZGVyLm1hcCgoaGVhZGVyVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShoZWFkZXJWYWx1ZSkpO1xuICAgICAgICAgICAgYWxsSGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyOiBhbGxIZWFkZXJzLFxuICAgICAgICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShwYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdG9rZW4uc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlVG9rZW4gPSBkZWNvZGVUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/decode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/ecdsaSigFormatter.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsontokens/lib/ecdsaSigFormatter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//  NOTICE\n//  Copyright 2015 D2L Corporation\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joseToDer = exports.derToJose = void 0;\n// The following code is adapted from https://github.com/Brightspace/node-ecdsa-sig-formatter\nconst base64_js_1 = __webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/base64-js/index.js\");\nconst base64Url_1 = __webpack_require__(/*! ./base64Url */ \"(ssr)/./node_modules/jsontokens/lib/base64Url.js\");\nfunction getParamSize(keySize) {\n    return ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);\n}\nconst paramBytesForAlg = {\n    ES256: getParamSize(256),\n    ES384: getParamSize(384),\n    ES512: getParamSize(521),\n};\nfunction getParamBytesForAlg(alg) {\n    const paramBytes = paramBytesForAlg[alg];\n    if (paramBytes) {\n        return paramBytes;\n    }\n    throw new Error(`Unknown algorithm \"${alg}\"`);\n}\nconst MAX_OCTET = 0x80;\nconst CLASS_UNIVERSAL = 0;\nconst PRIMITIVE_BIT = 0x20;\nconst TAG_SEQ = 0x10;\nconst TAG_INT = 0x02;\nconst ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6);\nconst ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\nfunction signatureAsBytes(signature) {\n    if (signature instanceof Uint8Array) {\n        return signature;\n    }\n    else if ('string' === typeof signature) {\n        return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));\n    }\n    throw new TypeError('ECDSA signature must be a Base64 string or a Uint8Array');\n}\nfunction derToJose(signature, alg) {\n    const signatureBytes = signatureAsBytes(signature);\n    const paramBytes = getParamBytesForAlg(alg);\n    // the DER encoded param should at most be the param size, plus a padding\n    // zero, since due to being a signed integer\n    const maxEncodedParamLength = paramBytes + 1;\n    const inputLength = signatureBytes.length;\n    let offset = 0;\n    if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {\n        throw new Error('Could not find expected \"seq\"');\n    }\n    let seqLength = signatureBytes[offset++];\n    if (seqLength === (MAX_OCTET | 1)) {\n        seqLength = signatureBytes[offset++];\n    }\n    if (inputLength - offset < seqLength) {\n        throw new Error(`\"seq\" specified length of \"${seqLength}\", only \"${inputLength - offset}\" remaining`);\n    }\n    if (signatureBytes[offset++] !== ENCODED_TAG_INT) {\n        throw new Error('Could not find expected \"int\" for \"r\"');\n    }\n    const rLength = signatureBytes[offset++];\n    if (inputLength - offset - 2 < rLength) {\n        throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`);\n    }\n    if (maxEncodedParamLength < rLength) {\n        throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n    }\n    const rOffset = offset;\n    offset += rLength;\n    if (signatureBytes[offset++] !== ENCODED_TAG_INT) {\n        throw new Error('Could not find expected \"int\" for \"s\"');\n    }\n    const sLength = signatureBytes[offset++];\n    if (inputLength - offset !== sLength) {\n        throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`);\n    }\n    if (maxEncodedParamLength < sLength) {\n        throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n    }\n    const sOffset = offset;\n    offset += sLength;\n    if (offset !== inputLength) {\n        throw new Error(`Expected to consume entire array, but \"${inputLength - offset}\" bytes remain`);\n    }\n    const rPadding = paramBytes - rLength;\n    const sPadding = paramBytes - sLength;\n    const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);\n    for (offset = 0; offset < rPadding; ++offset) {\n        dst[offset] = 0;\n    }\n    dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);\n    offset = paramBytes;\n    for (const o = offset; offset < o + sPadding; ++offset) {\n        dst[offset] = 0;\n    }\n    dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);\n    return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));\n}\nexports.derToJose = derToJose;\nfunction countPadding(buf, start, stop) {\n    let padding = 0;\n    while (start + padding < stop && buf[start + padding] === 0) {\n        ++padding;\n    }\n    const needsSign = buf[start + padding] >= MAX_OCTET;\n    if (needsSign) {\n        --padding;\n    }\n    return padding;\n}\nfunction joseToDer(signature, alg) {\n    signature = signatureAsBytes(signature);\n    const paramBytes = getParamBytesForAlg(alg);\n    const signatureBytes = signature.length;\n    if (signatureBytes !== paramBytes * 2) {\n        throw new TypeError(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`);\n    }\n    const rPadding = countPadding(signature, 0, paramBytes);\n    const sPadding = countPadding(signature, paramBytes, signature.length);\n    const rLength = paramBytes - rPadding;\n    const sLength = paramBytes - sPadding;\n    const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n    const shortLength = rsBytes < MAX_OCTET;\n    const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);\n    let offset = 0;\n    dst[offset++] = ENCODED_TAG_SEQ;\n    if (shortLength) {\n        // Bit 8 has value \"0\"\n        // bits 7-1 give the length.\n        dst[offset++] = rsBytes;\n    }\n    else {\n        // Bit 8 of first octet has value \"1\"\n        // bits 7-1 give the number of additional length octets.\n        dst[offset++] = MAX_OCTET | 1;\n        // length, base 256\n        dst[offset++] = rsBytes & 0xff;\n    }\n    dst[offset++] = ENCODED_TAG_INT;\n    dst[offset++] = rLength;\n    if (rPadding < 0) {\n        dst[offset++] = 0;\n        dst.set(signature.subarray(0, paramBytes), offset);\n        offset += paramBytes;\n    }\n    else {\n        dst.set(signature.subarray(rPadding, paramBytes), offset);\n        offset += paramBytes - rPadding;\n    }\n    dst[offset++] = ENCODED_TAG_INT;\n    dst[offset++] = sLength;\n    if (sPadding < 0) {\n        dst[offset++] = 0;\n        dst.set(signature.subarray(paramBytes), offset);\n    }\n    else {\n        dst.set(signature.subarray(paramBytes + sPadding), offset);\n    }\n    return dst;\n}\nexports.joseToDer = joseToDer;\n//# sourceMappingURL=ecdsaSigFormatter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvZWNkc2FTaWdGb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGlCQUFpQjtBQUNyQztBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVUsV0FBVyxxQkFBcUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVEsV0FBVyx5QkFBeUI7QUFDaEc7QUFDQTtBQUNBLG9EQUFvRCxRQUFRLGFBQWEsc0JBQXNCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUSxlQUFlLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0Esb0RBQW9ELFFBQVEsYUFBYSxzQkFBc0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLHdCQUF3QixlQUFlLGdCQUFnQixlQUFlO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIkM6XFxOYW1hbiBTaW5naHZpIFBlcnNvbmFsXFxIYXJ2YXJkIEhhY2thdGhvblxcZml0QlRDXFxmaXRCVEMgbWFpblxcbm9kZV9tb2R1bGVzXFxqc29udG9rZW5zXFxsaWJcXGVjZHNhU2lnRm9ybWF0dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gIE5PVElDRVxuLy8gIENvcHlyaWdodCAyMDE1IEQyTCBDb3Jwb3JhdGlvblxuLy9cbi8vICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuam9zZVRvRGVyID0gZXhwb3J0cy5kZXJUb0pvc2UgPSB2b2lkIDA7XG4vLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9CcmlnaHRzcGFjZS9ub2RlLWVjZHNhLXNpZy1mb3JtYXR0ZXJcbmNvbnN0IGJhc2U2NF9qc18xID0gcmVxdWlyZShcImJhc2U2NC1qc1wiKTtcbmNvbnN0IGJhc2U2NFVybF8xID0gcmVxdWlyZShcIi4vYmFzZTY0VXJsXCIpO1xuZnVuY3Rpb24gZ2V0UGFyYW1TaXplKGtleVNpemUpIHtcbiAgICByZXR1cm4gKChrZXlTaXplIC8gOCkgfCAwKSArIChrZXlTaXplICUgOCA9PT0gMCA/IDAgOiAxKTtcbn1cbmNvbnN0IHBhcmFtQnl0ZXNGb3JBbGcgPSB7XG4gICAgRVMyNTY6IGdldFBhcmFtU2l6ZSgyNTYpLFxuICAgIEVTMzg0OiBnZXRQYXJhbVNpemUoMzg0KSxcbiAgICBFUzUxMjogZ2V0UGFyYW1TaXplKDUyMSksXG59O1xuZnVuY3Rpb24gZ2V0UGFyYW1CeXRlc0ZvckFsZyhhbGcpIHtcbiAgICBjb25zdCBwYXJhbUJ5dGVzID0gcGFyYW1CeXRlc0ZvckFsZ1thbGddO1xuICAgIGlmIChwYXJhbUJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBwYXJhbUJ5dGVzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWxnb3JpdGhtIFwiJHthbGd9XCJgKTtcbn1cbmNvbnN0IE1BWF9PQ1RFVCA9IDB4ODA7XG5jb25zdCBDTEFTU19VTklWRVJTQUwgPSAwO1xuY29uc3QgUFJJTUlUSVZFX0JJVCA9IDB4MjA7XG5jb25zdCBUQUdfU0VRID0gMHgxMDtcbmNvbnN0IFRBR19JTlQgPSAweDAyO1xuY29uc3QgRU5DT0RFRF9UQUdfU0VRID0gVEFHX1NFUSB8IFBSSU1JVElWRV9CSVQgfCAoQ0xBU1NfVU5JVkVSU0FMIDw8IDYpO1xuY29uc3QgRU5DT0RFRF9UQUdfSU5UID0gVEFHX0lOVCB8IChDTEFTU19VTklWRVJTQUwgPDwgNik7XG5mdW5jdGlvbiBzaWduYXR1cmVBc0J5dGVzKHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiAoMCwgYmFzZTY0X2pzXzEudG9CeXRlQXJyYXkpKCgwLCBiYXNlNjRVcmxfMS5wYWQpKHNpZ25hdHVyZSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFQ0RTQSBzaWduYXR1cmUgbXVzdCBiZSBhIEJhc2U2NCBzdHJpbmcgb3IgYSBVaW50OEFycmF5Jyk7XG59XG5mdW5jdGlvbiBkZXJUb0pvc2Uoc2lnbmF0dXJlLCBhbGcpIHtcbiAgICBjb25zdCBzaWduYXR1cmVCeXRlcyA9IHNpZ25hdHVyZUFzQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBwYXJhbUJ5dGVzID0gZ2V0UGFyYW1CeXRlc0ZvckFsZyhhbGcpO1xuICAgIC8vIHRoZSBERVIgZW5jb2RlZCBwYXJhbSBzaG91bGQgYXQgbW9zdCBiZSB0aGUgcGFyYW0gc2l6ZSwgcGx1cyBhIHBhZGRpbmdcbiAgICAvLyB6ZXJvLCBzaW5jZSBkdWUgdG8gYmVpbmcgYSBzaWduZWQgaW50ZWdlclxuICAgIGNvbnN0IG1heEVuY29kZWRQYXJhbUxlbmd0aCA9IHBhcmFtQnl0ZXMgKyAxO1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gc2lnbmF0dXJlQnl0ZXMubGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGlmIChzaWduYXR1cmVCeXRlc1tvZmZzZXQrK10gIT09IEVOQ09ERURfVEFHX1NFUSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFwic2VxXCInKTtcbiAgICB9XG4gICAgbGV0IHNlcUxlbmd0aCA9IHNpZ25hdHVyZUJ5dGVzW29mZnNldCsrXTtcbiAgICBpZiAoc2VxTGVuZ3RoID09PSAoTUFYX09DVEVUIHwgMSkpIHtcbiAgICAgICAgc2VxTGVuZ3RoID0gc2lnbmF0dXJlQnl0ZXNbb2Zmc2V0KytdO1xuICAgIH1cbiAgICBpZiAoaW5wdXRMZW5ndGggLSBvZmZzZXQgPCBzZXFMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcInNlcVwiIHNwZWNpZmllZCBsZW5ndGggb2YgXCIke3NlcUxlbmd0aH1cIiwgb25seSBcIiR7aW5wdXRMZW5ndGggLSBvZmZzZXR9XCIgcmVtYWluaW5nYCk7XG4gICAgfVxuICAgIGlmIChzaWduYXR1cmVCeXRlc1tvZmZzZXQrK10gIT09IEVOQ09ERURfVEFHX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFwiaW50XCIgZm9yIFwiclwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHJMZW5ndGggPSBzaWduYXR1cmVCeXRlc1tvZmZzZXQrK107XG4gICAgaWYgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0IC0gMiA8IHJMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcInJcIiBzcGVjaWZpZWQgbGVuZ3RoIG9mIFwiJHtyTGVuZ3RofVwiLCBvbmx5IFwiJHtpbnB1dExlbmd0aCAtIG9mZnNldCAtIDJ9XCIgYXZhaWxhYmxlYCk7XG4gICAgfVxuICAgIGlmIChtYXhFbmNvZGVkUGFyYW1MZW5ndGggPCByTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJyXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIiR7ckxlbmd0aH1cIiwgbWF4IG9mIFwiJHttYXhFbmNvZGVkUGFyYW1MZW5ndGh9XCIgaXMgYWNjZXB0YWJsZWApO1xuICAgIH1cbiAgICBjb25zdCByT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIG9mZnNldCArPSByTGVuZ3RoO1xuICAgIGlmIChzaWduYXR1cmVCeXRlc1tvZmZzZXQrK10gIT09IEVOQ09ERURfVEFHX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFwiaW50XCIgZm9yIFwic1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IHNMZW5ndGggPSBzaWduYXR1cmVCeXRlc1tvZmZzZXQrK107XG4gICAgaWYgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0ICE9PSBzTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJzXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIiR7c0xlbmd0aH1cIiwgZXhwZWN0ZWQgXCIke2lucHV0TGVuZ3RoIC0gb2Zmc2V0fVwiYCk7XG4gICAgfVxuICAgIGlmIChtYXhFbmNvZGVkUGFyYW1MZW5ndGggPCBzTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJzXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIiR7c0xlbmd0aH1cIiwgbWF4IG9mIFwiJHttYXhFbmNvZGVkUGFyYW1MZW5ndGh9XCIgaXMgYWNjZXB0YWJsZWApO1xuICAgIH1cbiAgICBjb25zdCBzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIG9mZnNldCArPSBzTGVuZ3RoO1xuICAgIGlmIChvZmZzZXQgIT09IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdG8gY29uc3VtZSBlbnRpcmUgYXJyYXksIGJ1dCBcIiR7aW5wdXRMZW5ndGggLSBvZmZzZXR9XCIgYnl0ZXMgcmVtYWluYCk7XG4gICAgfVxuICAgIGNvbnN0IHJQYWRkaW5nID0gcGFyYW1CeXRlcyAtIHJMZW5ndGg7XG4gICAgY29uc3Qgc1BhZGRpbmcgPSBwYXJhbUJ5dGVzIC0gc0xlbmd0aDtcbiAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheShyUGFkZGluZyArIHJMZW5ndGggKyBzUGFkZGluZyArIHNMZW5ndGgpO1xuICAgIGZvciAob2Zmc2V0ID0gMDsgb2Zmc2V0IDwgclBhZGRpbmc7ICsrb2Zmc2V0KSB7XG4gICAgICAgIGRzdFtvZmZzZXRdID0gMDtcbiAgICB9XG4gICAgZHN0LnNldChzaWduYXR1cmVCeXRlcy5zdWJhcnJheShyT2Zmc2V0ICsgTWF0aC5tYXgoLXJQYWRkaW5nLCAwKSwgck9mZnNldCArIHJMZW5ndGgpLCBvZmZzZXQpO1xuICAgIG9mZnNldCA9IHBhcmFtQnl0ZXM7XG4gICAgZm9yIChjb25zdCBvID0gb2Zmc2V0OyBvZmZzZXQgPCBvICsgc1BhZGRpbmc7ICsrb2Zmc2V0KSB7XG4gICAgICAgIGRzdFtvZmZzZXRdID0gMDtcbiAgICB9XG4gICAgZHN0LnNldChzaWduYXR1cmVCeXRlcy5zdWJhcnJheShzT2Zmc2V0ICsgTWF0aC5tYXgoLXNQYWRkaW5nLCAwKSwgc09mZnNldCArIHNMZW5ndGgpLCBvZmZzZXQpO1xuICAgIHJldHVybiAoMCwgYmFzZTY0VXJsXzEuZXNjYXBlKSgoMCwgYmFzZTY0X2pzXzEuZnJvbUJ5dGVBcnJheSkoZHN0KSk7XG59XG5leHBvcnRzLmRlclRvSm9zZSA9IGRlclRvSm9zZTtcbmZ1bmN0aW9uIGNvdW50UGFkZGluZyhidWYsIHN0YXJ0LCBzdG9wKSB7XG4gICAgbGV0IHBhZGRpbmcgPSAwO1xuICAgIHdoaWxlIChzdGFydCArIHBhZGRpbmcgPCBzdG9wICYmIGJ1ZltzdGFydCArIHBhZGRpbmddID09PSAwKSB7XG4gICAgICAgICsrcGFkZGluZztcbiAgICB9XG4gICAgY29uc3QgbmVlZHNTaWduID0gYnVmW3N0YXJ0ICsgcGFkZGluZ10gPj0gTUFYX09DVEVUO1xuICAgIGlmIChuZWVkc1NpZ24pIHtcbiAgICAgICAgLS1wYWRkaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcGFkZGluZztcbn1cbmZ1bmN0aW9uIGpvc2VUb0RlcihzaWduYXR1cmUsIGFsZykge1xuICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZUFzQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBwYXJhbUJ5dGVzID0gZ2V0UGFyYW1CeXRlc0ZvckFsZyhhbGcpO1xuICAgIGNvbnN0IHNpZ25hdHVyZUJ5dGVzID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICBpZiAoc2lnbmF0dXJlQnl0ZXMgIT09IHBhcmFtQnl0ZXMgKiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiJHthbGd9XCIgc2lnbmF0dXJlcyBtdXN0IGJlIFwiJHtwYXJhbUJ5dGVzICogMn1cIiBieXRlcywgc2F3IFwiJHtzaWduYXR1cmVCeXRlc31cImApO1xuICAgIH1cbiAgICBjb25zdCByUGFkZGluZyA9IGNvdW50UGFkZGluZyhzaWduYXR1cmUsIDAsIHBhcmFtQnl0ZXMpO1xuICAgIGNvbnN0IHNQYWRkaW5nID0gY291bnRQYWRkaW5nKHNpZ25hdHVyZSwgcGFyYW1CeXRlcywgc2lnbmF0dXJlLmxlbmd0aCk7XG4gICAgY29uc3Qgckxlbmd0aCA9IHBhcmFtQnl0ZXMgLSByUGFkZGluZztcbiAgICBjb25zdCBzTGVuZ3RoID0gcGFyYW1CeXRlcyAtIHNQYWRkaW5nO1xuICAgIGNvbnN0IHJzQnl0ZXMgPSAxICsgMSArIHJMZW5ndGggKyAxICsgMSArIHNMZW5ndGg7XG4gICAgY29uc3Qgc2hvcnRMZW5ndGggPSByc0J5dGVzIDwgTUFYX09DVEVUO1xuICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KChzaG9ydExlbmd0aCA/IDIgOiAzKSArIHJzQnl0ZXMpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGRzdFtvZmZzZXQrK10gPSBFTkNPREVEX1RBR19TRVE7XG4gICAgaWYgKHNob3J0TGVuZ3RoKSB7XG4gICAgICAgIC8vIEJpdCA4IGhhcyB2YWx1ZSBcIjBcIlxuICAgICAgICAvLyBiaXRzIDctMSBnaXZlIHRoZSBsZW5ndGguXG4gICAgICAgIGRzdFtvZmZzZXQrK10gPSByc0J5dGVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQml0IDggb2YgZmlyc3Qgb2N0ZXQgaGFzIHZhbHVlIFwiMVwiXG4gICAgICAgIC8vIGJpdHMgNy0xIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIGxlbmd0aCBvY3RldHMuXG4gICAgICAgIGRzdFtvZmZzZXQrK10gPSBNQVhfT0NURVQgfCAxO1xuICAgICAgICAvLyBsZW5ndGgsIGJhc2UgMjU2XG4gICAgICAgIGRzdFtvZmZzZXQrK10gPSByc0J5dGVzICYgMHhmZjtcbiAgICB9XG4gICAgZHN0W29mZnNldCsrXSA9IEVOQ09ERURfVEFHX0lOVDtcbiAgICBkc3Rbb2Zmc2V0KytdID0gckxlbmd0aDtcbiAgICBpZiAoclBhZGRpbmcgPCAwKSB7XG4gICAgICAgIGRzdFtvZmZzZXQrK10gPSAwO1xuICAgICAgICBkc3Quc2V0KHNpZ25hdHVyZS5zdWJhcnJheSgwLCBwYXJhbUJ5dGVzKSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHBhcmFtQnl0ZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkc3Quc2V0KHNpZ25hdHVyZS5zdWJhcnJheShyUGFkZGluZywgcGFyYW1CeXRlcyksIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBwYXJhbUJ5dGVzIC0gclBhZGRpbmc7XG4gICAgfVxuICAgIGRzdFtvZmZzZXQrK10gPSBFTkNPREVEX1RBR19JTlQ7XG4gICAgZHN0W29mZnNldCsrXSA9IHNMZW5ndGg7XG4gICAgaWYgKHNQYWRkaW5nIDwgMCkge1xuICAgICAgICBkc3Rbb2Zmc2V0KytdID0gMDtcbiAgICAgICAgZHN0LnNldChzaWduYXR1cmUuc3ViYXJyYXkocGFyYW1CeXRlcyksIG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkc3Quc2V0KHNpZ25hdHVyZS5zdWJhcnJheShwYXJhbUJ5dGVzICsgc1BhZGRpbmcpLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufVxuZXhwb3J0cy5qb3NlVG9EZXIgPSBqb3NlVG9EZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2RzYVNpZ0Zvcm1hdHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/ecdsaSigFormatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/errors.js":
/*!***********************************************!*\
  !*** ./node_modules/jsontokens/lib/errors.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidTokenError = exports.MissingParametersError = void 0;\nclass MissingParametersError extends Error {\n    constructor(message) {\n        super();\n        this.name = 'MissingParametersError';\n        this.message = message || '';\n    }\n}\nexports.MissingParametersError = MissingParametersError;\nclass InvalidTokenError extends Error {\n    constructor(message) {\n        super();\n        this.name = 'InvalidTokenError';\n        this.message = message || '';\n    }\n}\nexports.InvalidTokenError = InvalidTokenError;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiQzpcXE5hbWFuIFNpbmdodmkgUGVyc29uYWxcXEhhcnZhcmQgSGFja2F0aG9uXFxmaXRCVENcXGZpdEJUQyBtYWluXFxub2RlX21vZHVsZXNcXGpzb250b2tlbnNcXGxpYlxcZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkVG9rZW5FcnJvciA9IGV4cG9ydHMuTWlzc2luZ1BhcmFtZXRlcnNFcnJvciA9IHZvaWQgMDtcbmNsYXNzIE1pc3NpbmdQYXJhbWV0ZXJzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1BhcmFtZXRlcnNFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG4gICAgfVxufVxuZXhwb3J0cy5NaXNzaW5nUGFyYW1ldGVyc0Vycm9yID0gTWlzc2luZ1BhcmFtZXRlcnNFcnJvcjtcbmNsYXNzIEludmFsaWRUb2tlbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRUb2tlbkVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRUb2tlbkVycm9yID0gSW52YWxpZFRva2VuRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/jsontokens/lib/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./signer */ \"(ssr)/./node_modules/jsontokens/lib/signer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/jsontokens/lib/verifier.js\"), exports);\n__exportStar(__webpack_require__(/*! ./decode */ \"(ssr)/./node_modules/jsontokens/lib/decode.js\"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/jsontokens/lib/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cryptoClients */ \"(ssr)/./node_modules/jsontokens/lib/cryptoClients/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLCtEQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxtRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsK0RBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtEQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDdEMiLCJzb3VyY2VzIjpbIkM6XFxOYW1hbiBTaW5naHZpIFBlcnNvbmFsXFxIYXJ2YXJkIEhhY2thdGhvblxcZml0QlRDXFxmaXRCVEMgbWFpblxcbm9kZV9tb2R1bGVzXFxqc29udG9rZW5zXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZXJpZmllclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVjb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyeXB0b0NsaWVudHNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/signer.js":
/*!***********************************************!*\
  !*** ./node_modules/jsontokens/lib/signer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenSigner = exports.createUnsecuredToken = void 0;\nconst base64url = __webpack_require__(/*! ./base64Url */ \"(ssr)/./node_modules/jsontokens/lib/base64Url.js\");\nconst cryptoClients_1 = __webpack_require__(/*! ./cryptoClients */ \"(ssr)/./node_modules/jsontokens/lib/cryptoClients/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/jsontokens/lib/errors.js\");\nconst sha256_1 = __webpack_require__(/*! ./cryptoClients/sha256 */ \"(ssr)/./node_modules/jsontokens/lib/cryptoClients/sha256.js\");\nfunction createSigningInput(payload, header) {\n    const tokenParts = [];\n    // add in the header\n    const encodedHeader = base64url.encode(JSON.stringify(header));\n    tokenParts.push(encodedHeader);\n    // add in the payload\n    const encodedPayload = base64url.encode(JSON.stringify(payload));\n    tokenParts.push(encodedPayload);\n    // prepare the message\n    const signingInput = tokenParts.join('.');\n    // return the signing input\n    return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n    const header = { typ: 'JWT', alg: 'none' };\n    return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n    constructor(signingAlgorithm, rawPrivateKey) {\n        if (!(signingAlgorithm && rawPrivateKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw new Error('signing algorithm parameter must be a string');\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw new Error('invalid signing algorithm');\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPrivateKey = rawPrivateKey;\n    }\n    header(header = {}) {\n        const defaultHeader = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };\n        return Object.assign({}, defaultHeader, header);\n    }\n    sign(payload, expanded = false, customHeader = {}) {\n        // generate the token header\n        const header = this.header(customHeader);\n        // prepare the message to be signed\n        const signingInput = createSigningInput(payload, header);\n        const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    }\n    signAsync(payload, expanded = false, customHeader = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // generate the token header\n            const header = this.header(customHeader);\n            // prepare the message to be signed\n            const signingInput = createSigningInput(payload, header);\n            const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);\n            return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n        });\n    }\n    createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n        // sign the message and add in the signature\n        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n        if (expanded) {\n            const signedToken = {\n                header: [base64url.encode(JSON.stringify(header))],\n                payload: JSON.stringify(payload),\n                signature: [signature],\n            };\n            return signedToken;\n        }\n        else {\n            return [signingInput, signature].join('.');\n        }\n    }\n}\nexports.TokenSigner = TokenSigner;\n//# sourceMappingURL=signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvc2lnbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyw0QkFBNEI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMscUVBQWE7QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsbUZBQWlCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLCtEQUFVO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDJGQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJDOlxcTmFtYW4gU2luZ2h2aSBQZXJzb25hbFxcSGFydmFyZCBIYWNrYXRob25cXGZpdEJUQ1xcZml0QlRDIG1haW5cXG5vZGVfbW9kdWxlc1xcanNvbnRva2Vuc1xcbGliXFxzaWduZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5TaWduZXIgPSBleHBvcnRzLmNyZWF0ZVVuc2VjdXJlZFRva2VuID0gdm9pZCAwO1xuY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZShcIi4vYmFzZTY0VXJsXCIpO1xuY29uc3QgY3J5cHRvQ2xpZW50c18xID0gcmVxdWlyZShcIi4vY3J5cHRvQ2xpZW50c1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiLi9jcnlwdG9DbGllbnRzL3NoYTI1NlwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVNpZ25pbmdJbnB1dChwYXlsb2FkLCBoZWFkZXIpIHtcbiAgICBjb25zdCB0b2tlblBhcnRzID0gW107XG4gICAgLy8gYWRkIGluIHRoZSBoZWFkZXJcbiAgICBjb25zdCBlbmNvZGVkSGVhZGVyID0gYmFzZTY0dXJsLmVuY29kZShKU09OLnN0cmluZ2lmeShoZWFkZXIpKTtcbiAgICB0b2tlblBhcnRzLnB1c2goZW5jb2RlZEhlYWRlcik7XG4gICAgLy8gYWRkIGluIHRoZSBwYXlsb2FkXG4gICAgY29uc3QgZW5jb2RlZFBheWxvYWQgPSBiYXNlNjR1cmwuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICB0b2tlblBhcnRzLnB1c2goZW5jb2RlZFBheWxvYWQpO1xuICAgIC8vIHByZXBhcmUgdGhlIG1lc3NhZ2VcbiAgICBjb25zdCBzaWduaW5nSW5wdXQgPSB0b2tlblBhcnRzLmpvaW4oJy4nKTtcbiAgICAvLyByZXR1cm4gdGhlIHNpZ25pbmcgaW5wdXRcbiAgICByZXR1cm4gc2lnbmluZ0lucHV0O1xufVxuZnVuY3Rpb24gY3JlYXRlVW5zZWN1cmVkVG9rZW4ocGF5bG9hZCkge1xuICAgIGNvbnN0IGhlYWRlciA9IHsgdHlwOiAnSldUJywgYWxnOiAnbm9uZScgfTtcbiAgICByZXR1cm4gY3JlYXRlU2lnbmluZ0lucHV0KHBheWxvYWQsIGhlYWRlcikgKyAnLic7XG59XG5leHBvcnRzLmNyZWF0ZVVuc2VjdXJlZFRva2VuID0gY3JlYXRlVW5zZWN1cmVkVG9rZW47XG5jbGFzcyBUb2tlblNpZ25lciB7XG4gICAgY29uc3RydWN0b3Ioc2lnbmluZ0FsZ29yaXRobSwgcmF3UHJpdmF0ZUtleSkge1xuICAgICAgICBpZiAoIShzaWduaW5nQWxnb3JpdGhtICYmIHJhd1ByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTWlzc2luZ1BhcmFtZXRlcnNFcnJvcignYSBzaWduaW5nIGFsZ29yaXRobSBhbmQgcHJpdmF0ZSBrZXkgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzaWduaW5nQWxnb3JpdGhtICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduaW5nIGFsZ29yaXRobSBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25pbmdBbGdvcml0aG0gPSBzaWduaW5nQWxnb3JpdGhtLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmICghY3J5cHRvQ2xpZW50c18xLmNyeXB0b0NsaWVudHMuaGFzT3duUHJvcGVydHkoc2lnbmluZ0FsZ29yaXRobSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduaW5nIGFsZ29yaXRobScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gJ0pXVCc7XG4gICAgICAgIHRoaXMuY3J5cHRvQ2xpZW50ID0gY3J5cHRvQ2xpZW50c18xLmNyeXB0b0NsaWVudHNbc2lnbmluZ0FsZ29yaXRobV07XG4gICAgICAgIHRoaXMucmF3UHJpdmF0ZUtleSA9IHJhd1ByaXZhdGVLZXk7XG4gICAgfVxuICAgIGhlYWRlcihoZWFkZXIgPSB7fSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0SGVhZGVyID0geyB0eXA6IHRoaXMudG9rZW5UeXBlLCBhbGc6IHRoaXMuY3J5cHRvQ2xpZW50LmFsZ29yaXRobU5hbWUgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIZWFkZXIsIGhlYWRlcik7XG4gICAgfVxuICAgIHNpZ24ocGF5bG9hZCwgZXhwYW5kZWQgPSBmYWxzZSwgY3VzdG9tSGVhZGVyID0ge30pIHtcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHRva2VuIGhlYWRlclxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmhlYWRlcihjdXN0b21IZWFkZXIpO1xuICAgICAgICAvLyBwcmVwYXJlIHRoZSBtZXNzYWdlIHRvIGJlIHNpZ25lZFxuICAgICAgICBjb25zdCBzaWduaW5nSW5wdXQgPSBjcmVhdGVTaWduaW5nSW5wdXQocGF5bG9hZCwgaGVhZGVyKTtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0lucHV0SGFzaCA9ICgwLCBzaGEyNTZfMS5oYXNoU2hhMjU2KShzaWduaW5nSW5wdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVXaXRoU2lnbmVkSGFzaChwYXlsb2FkLCBleHBhbmRlZCwgaGVhZGVyLCBzaWduaW5nSW5wdXQsIHNpZ25pbmdJbnB1dEhhc2gpO1xuICAgIH1cbiAgICBzaWduQXN5bmMocGF5bG9hZCwgZXhwYW5kZWQgPSBmYWxzZSwgY3VzdG9tSGVhZGVyID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSB0b2tlbiBoZWFkZXJcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuaGVhZGVyKGN1c3RvbUhlYWRlcik7XG4gICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSBtZXNzYWdlIHRvIGJlIHNpZ25lZFxuICAgICAgICAgICAgY29uc3Qgc2lnbmluZ0lucHV0ID0gY3JlYXRlU2lnbmluZ0lucHV0KHBheWxvYWQsIGhlYWRlcik7XG4gICAgICAgICAgICBjb25zdCBzaWduaW5nSW5wdXRIYXNoID0geWllbGQgKDAsIHNoYTI1Nl8xLmhhc2hTaGEyNTZBc3luYykoc2lnbmluZ0lucHV0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVdpdGhTaWduZWRIYXNoKHBheWxvYWQsIGV4cGFuZGVkLCBoZWFkZXIsIHNpZ25pbmdJbnB1dCwgc2lnbmluZ0lucHV0SGFzaCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVXaXRoU2lnbmVkSGFzaChwYXlsb2FkLCBleHBhbmRlZCwgaGVhZGVyLCBzaWduaW5nSW5wdXQsIHNpZ25pbmdJbnB1dEhhc2gpIHtcbiAgICAgICAgLy8gc2lnbiB0aGUgbWVzc2FnZSBhbmQgYWRkIGluIHRoZSBzaWduYXR1cmVcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5jcnlwdG9DbGllbnQuc2lnbkhhc2goc2lnbmluZ0lucHV0SGFzaCwgdGhpcy5yYXdQcml2YXRlS2V5KTtcbiAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUb2tlbiA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IFtiYXNlNjR1cmwuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpXSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFtzaWduYXR1cmVdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzaWduZWRUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbc2lnbmluZ0lucHV0LCBzaWduYXR1cmVdLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5TaWduZXIgPSBUb2tlblNpZ25lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25lci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsontokens/lib/verifier.js":
/*!*************************************************!*\
  !*** ./node_modules/jsontokens/lib/verifier.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenVerifier = void 0;\nconst base64url = __webpack_require__(/*! ./base64Url */ \"(ssr)/./node_modules/jsontokens/lib/base64Url.js\");\nconst cryptoClients_1 = __webpack_require__(/*! ./cryptoClients */ \"(ssr)/./node_modules/jsontokens/lib/cryptoClients/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/jsontokens/lib/errors.js\");\nconst sha256_1 = __webpack_require__(/*! ./cryptoClients/sha256 */ \"(ssr)/./node_modules/jsontokens/lib/cryptoClients/sha256.js\");\nclass TokenVerifier {\n    constructor(signingAlgorithm, rawPublicKey) {\n        if (!(signingAlgorithm && rawPublicKey)) {\n            throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n        }\n        if (typeof signingAlgorithm !== 'string') {\n            throw 'signing algorithm parameter must be a string';\n        }\n        signingAlgorithm = signingAlgorithm.toUpperCase();\n        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n            throw 'invalid signing algorithm';\n        }\n        this.tokenType = 'JWT';\n        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n        this.rawPublicKey = rawPublicKey;\n    }\n    verify(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token, false);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token, false);\n        }\n        else {\n            return false;\n        }\n    }\n    verifyAsync(token) {\n        if (typeof token === 'string') {\n            return this.verifyCompact(token, true);\n        }\n        else if (typeof token === 'object') {\n            return this.verifyExpanded(token, true);\n        }\n        else {\n            return Promise.resolve(false);\n        }\n    }\n    verifyCompact(token, async) {\n        // decompose the token into parts\n        const tokenParts = token.split('.');\n        // calculate the signing input hash\n        const signingInput = tokenParts[0] + '.' + tokenParts[1];\n        const performVerify = (signingInputHash) => {\n            // extract the signature as a DER array\n            const derSignatureBytes = this.cryptoClient.loadSignature(tokenParts[2]);\n            // verify the signed hash\n            return this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);\n        };\n        if (async) {\n            return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));\n        }\n        else {\n            const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n            return performVerify(signingInputHash);\n        }\n    }\n    verifyExpanded(token, async) {\n        const signingInput = [token['header'].join('.'), base64url.encode(token['payload'])].join('.');\n        let verified = true;\n        const performVerify = (signingInputHash) => {\n            token['signature'].map((signature) => {\n                const derSignatureBytes = this.cryptoClient.loadSignature(signature);\n                const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);\n                if (!signatureVerified) {\n                    verified = false;\n                }\n            });\n            return verified;\n        };\n        if (async) {\n            return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));\n        }\n        else {\n            const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n            return performVerify(signingInputHash);\n        }\n    }\n}\nexports.TokenVerifier = TokenVerifier;\n//# sourceMappingURL=verifier.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnRva2Vucy9saWIvdmVyaWZpZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3ZDLHdCQUF3QixtQkFBTyxDQUFDLG1GQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQywrREFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiQzpcXE5hbWFuIFNpbmdodmkgUGVyc29uYWxcXEhhcnZhcmQgSGFja2F0aG9uXFxmaXRCVENcXGZpdEJUQyBtYWluXFxub2RlX21vZHVsZXNcXGpzb250b2tlbnNcXGxpYlxcdmVyaWZpZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRva2VuVmVyaWZpZXIgPSB2b2lkIDA7XG5jb25zdCBiYXNlNjR1cmwgPSByZXF1aXJlKFwiLi9iYXNlNjRVcmxcIik7XG5jb25zdCBjcnlwdG9DbGllbnRzXzEgPSByZXF1aXJlKFwiLi9jcnlwdG9DbGllbnRzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCIuL2NyeXB0b0NsaWVudHMvc2hhMjU2XCIpO1xuY2xhc3MgVG9rZW5WZXJpZmllciB7XG4gICAgY29uc3RydWN0b3Ioc2lnbmluZ0FsZ29yaXRobSwgcmF3UHVibGljS2V5KSB7XG4gICAgICAgIGlmICghKHNpZ25pbmdBbGdvcml0aG0gJiYgcmF3UHVibGljS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk1pc3NpbmdQYXJhbWV0ZXJzRXJyb3IoJ2Egc2lnbmluZyBhbGdvcml0aG0gYW5kIHB1YmxpYyBrZXkgYXJlIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzaWduaW5nQWxnb3JpdGhtICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgJ3NpZ25pbmcgYWxnb3JpdGhtIHBhcmFtZXRlciBtdXN0IGJlIGEgc3RyaW5nJztcbiAgICAgICAgfVxuICAgICAgICBzaWduaW5nQWxnb3JpdGhtID0gc2lnbmluZ0FsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoIWNyeXB0b0NsaWVudHNfMS5jcnlwdG9DbGllbnRzLmhhc093blByb3BlcnR5KHNpZ25pbmdBbGdvcml0aG0pKSB7XG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBzaWduaW5nIGFsZ29yaXRobSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSAnSldUJztcbiAgICAgICAgdGhpcy5jcnlwdG9DbGllbnQgPSBjcnlwdG9DbGllbnRzXzEuY3J5cHRvQ2xpZW50c1tzaWduaW5nQWxnb3JpdGhtXTtcbiAgICAgICAgdGhpcy5yYXdQdWJsaWNLZXkgPSByYXdQdWJsaWNLZXk7XG4gICAgfVxuICAgIHZlcmlmeSh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5Q29tcGFjdCh0b2tlbiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUV4cGFuZGVkKHRva2VuLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5QXN5bmModG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUNvbXBhY3QodG9rZW4sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUV4cGFuZGVkKHRva2VuLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeUNvbXBhY3QodG9rZW4sIGFzeW5jKSB7XG4gICAgICAgIC8vIGRlY29tcG9zZSB0aGUgdG9rZW4gaW50byBwYXJ0c1xuICAgICAgICBjb25zdCB0b2tlblBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaWduaW5nIGlucHV0IGhhc2hcbiAgICAgICAgY29uc3Qgc2lnbmluZ0lucHV0ID0gdG9rZW5QYXJ0c1swXSArICcuJyArIHRva2VuUGFydHNbMV07XG4gICAgICAgIGNvbnN0IHBlcmZvcm1WZXJpZnkgPSAoc2lnbmluZ0lucHV0SGFzaCkgPT4ge1xuICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgc2lnbmF0dXJlIGFzIGEgREVSIGFycmF5XG4gICAgICAgICAgICBjb25zdCBkZXJTaWduYXR1cmVCeXRlcyA9IHRoaXMuY3J5cHRvQ2xpZW50LmxvYWRTaWduYXR1cmUodG9rZW5QYXJ0c1syXSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgdGhlIHNpZ25lZCBoYXNoXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9DbGllbnQudmVyaWZ5SGFzaChzaWduaW5nSW5wdXRIYXNoLCBkZXJTaWduYXR1cmVCeXRlcywgdGhpcy5yYXdQdWJsaWNLZXkpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgc2hhMjU2XzEuaGFzaFNoYTI1NkFzeW5jKShzaWduaW5nSW5wdXQpLnRoZW4oc2lnbmluZ0lucHV0SGFzaCA9PiBwZXJmb3JtVmVyaWZ5KHNpZ25pbmdJbnB1dEhhc2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdJbnB1dEhhc2ggPSAoMCwgc2hhMjU2XzEuaGFzaFNoYTI1Nikoc2lnbmluZ0lucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBwZXJmb3JtVmVyaWZ5KHNpZ25pbmdJbnB1dEhhc2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZlcmlmeUV4cGFuZGVkKHRva2VuLCBhc3luYykge1xuICAgICAgICBjb25zdCBzaWduaW5nSW5wdXQgPSBbdG9rZW5bJ2hlYWRlciddLmpvaW4oJy4nKSwgYmFzZTY0dXJsLmVuY29kZSh0b2tlblsncGF5bG9hZCddKV0uam9pbignLicpO1xuICAgICAgICBsZXQgdmVyaWZpZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBwZXJmb3JtVmVyaWZ5ID0gKHNpZ25pbmdJbnB1dEhhc2gpID0+IHtcbiAgICAgICAgICAgIHRva2VuWydzaWduYXR1cmUnXS5tYXAoKHNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlclNpZ25hdHVyZUJ5dGVzID0gdGhpcy5jcnlwdG9DbGllbnQubG9hZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZVZlcmlmaWVkID0gdGhpcy5jcnlwdG9DbGllbnQudmVyaWZ5SGFzaChzaWduaW5nSW5wdXRIYXNoLCBkZXJTaWduYXR1cmVCeXRlcywgdGhpcy5yYXdQdWJsaWNLZXkpO1xuICAgICAgICAgICAgICAgIGlmICghc2lnbmF0dXJlVmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllZDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHNoYTI1Nl8xLmhhc2hTaGEyNTZBc3luYykoc2lnbmluZ0lucHV0KS50aGVuKHNpZ25pbmdJbnB1dEhhc2ggPT4gcGVyZm9ybVZlcmlmeShzaWduaW5nSW5wdXRIYXNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaWduaW5nSW5wdXRIYXNoID0gKDAsIHNoYTI1Nl8xLmhhc2hTaGEyNTYpKHNpZ25pbmdJbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gcGVyZm9ybVZlcmlmeShzaWduaW5nSW5wdXRIYXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5WZXJpZmllciA9IFRva2VuVmVyaWZpZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJpZmllci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsontokens/lib/verifier.js\n");

/***/ })

};
;