/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/schema-inspector";
exports.ids = ["vendor-chunks/schema-inspector"];
exports.modules = {

/***/ "(ssr)/./node_modules/schema-inspector/index.js":
/*!************************************************!*\
  !*** ./node_modules/schema-inspector/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/schema-inspector */ \"(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtSUFBa0QiLCJzb3VyY2VzIjpbIkM6XFxOYW1hbiBTaW5naHZpIFBlcnNvbmFsXFxIYXJ2YXJkIEhhY2thdGhvblxcZml0QlRDXFxmaXRCVEMgbWFpblxcbm9kZV9tb2R1bGVzXFxzY2hlbWEtaW5zcGVjdG9yXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS1pbnNwZWN0b3InKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/schema-inspector/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js":
/*!***************************************************************!*\
  !*** ./node_modules/schema-inspector/lib/schema-inspector.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Disable no-var because we need to support old IE for now.\n/* eslint-disable no-var */\n// Disable space-before-function-paren for compatibility with VS Code default JS formatter.\n/* eslint-disable space-before-function-paren */\n\n/*\n * This module is intended to be executed both on client side and server side.\n * No error should be thrown. (soft error handling)\n */\n\n(function () {\n  var root = {};\n  // Dependencies --------------------------------------------------------------\n  root.async = ( true) ? __webpack_require__(/*! async */ \"(ssr)/./node_modules/async/dist/async.js\") : 0;\n  if (typeof root.async !== 'object') {\n    throw new Error('Module async is required (https://github.com/caolan/async)');\n  }\n  var async = root.async;\n\n  function _extend(origin, add) {\n    if (!add || typeof add !== 'object') {\n      return origin;\n    }\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n  }\n\n  function _merge() {\n    var ret = {};\n    var args = Array.prototype.slice.call(arguments);\n    var keys = null;\n    var i = null;\n\n    args.forEach(function (arg) {\n      if (arg && arg.constructor === Object) {\n        keys = Object.keys(arg);\n        i = keys.length;\n        while (i--) {\n          ret[keys[i]] = arg[keys[i]];\n        }\n      }\n    });\n    return ret;\n  }\n\n  // Customisable class (Base class) -------------------------------------------\n  // Use with operation \"new\" to extend Validation and Sanitization themselves,\n  // not their prototype. In other words, constructor shall be call to extend\n  // those functions, instead of being in their constructor, like this:\n  //   _extend(Validation, new Customisable);\n\n  function Customisable() {\n    this.custom = {};\n\n    this.extend = function (custom) {\n      return _extend(this.custom, custom);\n    };\n\n    this.reset = function () {\n      this.custom = {};\n    };\n\n    this.remove = function (fields) {\n      if (!_typeIs.array(fields)) {\n        fields = [fields];\n      }\n      fields.forEach(function (field) {\n        delete this.custom[field];\n      }, this);\n    };\n  }\n\n  // Inspection class (Base class) ---------------------------------------------\n  // Use to extend Validation and Sanitization prototypes. Inspection\n  // constructor shall be called in derived class constructor.\n\n  function Inspection(schema, custom) {\n    var _stack = ['@'];\n\n    this._schema = schema;\n    this._custom = {};\n    if (custom != null) {\n      for (var key in custom) {\n        if (Object.prototype.hasOwnProperty.call(custom, key)) {\n          this._custom['$' + key] = custom[key];\n        }\n      }\n    }\n\n    this._getDepth = function () {\n      return _stack.length;\n    };\n\n    this._dumpStack = function () {\n      /* eslint-disable no-control-regex */\n      return _stack.map(function (i) { return i.replace(/^\\[/g, '\\u001b\\u001c\\u001d\\u001e'); })\n        .join('.').replace(/\\.\\u001b\\u001c\\u001d\\u001e/g, '[');\n      /* eslint-enable no-control-regex */\n    };\n\n    this._deeperObject = function (name) {\n      _stack.push((/^[a-z$_][a-z0-9$_]*$/i).test(name) ? name : '[\"' + name + '\"]');\n      return this;\n    };\n\n    this._deeperArray = function (i) {\n      _stack.push('[' + i + ']');\n      return this;\n    };\n\n    this._back = function () {\n      _stack.pop();\n      return this;\n    };\n  }\n  // Simple types --------------------------------------------------------------\n  // If the property is not defined or is not in this list:\n  var _typeIs = {\n    function: function (element) {\n      return typeof element === 'function';\n    },\n    string: function (element) {\n      return typeof element === 'string';\n    },\n    number: function (element) {\n      return typeof element === 'number' && !isNaN(element);\n    },\n    integer: function (element) {\n      return typeof element === 'number' && element % 1 === 0;\n    },\n    NaN: function (element) {\n      return typeof element === 'number' && isNaN(element);\n    },\n    boolean: function (element) {\n      return typeof element === 'boolean';\n    },\n    null: function (element) {\n      return element === null;\n    },\n    date: function (element) {\n      return element != null && element instanceof Date;\n    },\n    object: function (element) {\n      return typeof element === 'object' && element != null && element.constructor !== Array;\n    },\n    array: function (element) {\n      return element != null && element.constructor === Array;\n    },\n    any: function () {\n      return true;\n    }\n  };\n\n  function _simpleType(type, candidate) {\n    if (typeof type === 'function') {\n      return candidate instanceof type;\n    }\n    type = type in _typeIs ? type : 'any';\n    return _typeIs[type](candidate);\n  }\n\n  function _realType(candidate) {\n    for (var i in _typeIs) {\n      if (_simpleType(i, candidate)) {\n        if (i !== 'any' && (i !== 'object' || candidate.constructor === Object)) { return i; }\n        return 'an instance of ' + candidate.constructor.name;\n      }\n    }\n  }\n\n  function getIndexes(a, value) {\n    var indexes = [];\n    var i = a.indexOf(value);\n\n    while (i !== -1) {\n      indexes.push(i);\n      i = a.indexOf(value, i + 1);\n    }\n    return indexes;\n  }\n\n  // Available formats ---------------------------------------------------------\n  /* eslint-disable no-useless-escape */\n  // TODO: Study these regex expressions and add more tests so we can consider removing\n  // rule no-useless-escape.\n  var _formats = {\n    void: /^$/,\n    url: /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)?(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i,\n    'date-time': /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?(Z?|(-|\\+)\\d{2}:\\d{2})$/,\n    date: /^\\d{4}-\\d{2}-\\d{2}$/,\n    coolDateTime: /^\\d{4}(-|\\/)\\d{2}(-|\\/)\\d{2}(T| )\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/,\n    time: /^\\d{2}\\:\\d{2}\\:\\d{2}$/,\n    color: /^#([0-9a-f])+$/i,\n    // Very flexible regular expression designed to catch only obvious mistakes\n    // that a user might make that would have a 100% chance of causing email\n    // delivery to the address to fail. The library takes a flexible over\n    // strict approach. Users should use this only for basic front end email\n    // address validation and perform more strict checking using server-side\n    // code after the data has been sent to their server.\n    // Sourced from https://www.regular-expressions.info/email.html, modified\n    // to allow lowercase characters too.\n    email: /^[^@]+@[^.]+\\.[a-zA-Z]+$/,\n    /* eslint-enable prefer-regex-literals */\n    /* eslint-enable quotes */\n    numeric: /^[0-9]+$/,\n    integer: /^\\-?[0-9]+$/,\n    decimal: /^\\-?[0-9]*\\.?[0-9]+$/,\n    alpha: /^[a-z]+$/i,\n    alphaNumeric: /^[a-z0-9]+$/i,\n    alphaDash: /^[a-z0-9_-]+$/i,\n    javascript: /^[a-z_\\$][a-z0-9_\\$]*$/i,\n    upperString: /^[A-Z ]*$/,\n    lowerString: /^[a-z ]*$/,\n    v4uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n  };\n  /* eslint-enable no-useless-escape */\n\n  // Validation ------------------------------------------------------------------\n  var _validationAttribut = {\n    optional: function (schema, candidate) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional === 'true'); // Default is false\n\n      if (opt === true) {\n        return;\n      }\n      if (typeof candidate === 'undefined') {\n        this.report('is missing and not optional', null, 'optional');\n      }\n    },\n    type: function (schema, candidate) {\n      // return because optional function already handle this case\n      if (typeof candidate === 'undefined' || (typeof schema.type !== 'string' && !(schema.type instanceof Array) && typeof schema.type !== 'function')) {\n        return;\n      }\n      var types = _typeIs.array(schema.type) ? schema.type : [schema.type];\n      var typeIsValid = types.some(function (type) {\n        return _simpleType(type, candidate);\n      });\n      if (!typeIsValid) {\n        types = types.map(function (t) { return typeof t === 'function' ? 'an instance of ' + t.name : t; });\n        this.report('must be ' + types.join(' or ') + ', but is ' + _realType(candidate), null, 'type');\n      }\n    },\n    uniqueness: function (schema, candidate) {\n      if (typeof schema.uniqueness === 'string') { schema.uniqueness = (schema.uniqueness === 'true'); }\n      if (typeof schema.uniqueness !== 'boolean' || schema.uniqueness === false || (!_typeIs.array(candidate) && typeof candidate !== 'string')) {\n        return;\n      }\n      var reported = [];\n      for (var i = 0; i < candidate.length; i++) {\n        if (reported.indexOf(candidate[i]) >= 0) {\n          continue;\n        }\n        var indexes = getIndexes(candidate, candidate[i]);\n        if (indexes.length > 1) {\n          reported.push(candidate[i]);\n          this.report('has value [' + candidate[i] + '] more than once at indexes [' + indexes.join(', ') + ']', null, 'uniqueness');\n        }\n      }\n    },\n    pattern: function (schema, candidate) {\n      var self = this;\n      var regexs = schema.pattern;\n      if (typeof candidate !== 'string') {\n        return;\n      }\n      var matches = false;\n      if (!_typeIs.array(regexs)) {\n        regexs = [regexs];\n      }\n      regexs.forEach(function (regex) {\n        if (typeof regex === 'string' && regex in _formats) {\n          regex = _formats[regex];\n        }\n        if (regex instanceof RegExp) {\n          if (regex.test(candidate)) {\n            matches = true;\n          }\n        }\n      });\n      if (!matches) {\n        self.report('must match [' + regexs.join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'pattern');\n      }\n    },\n    validDate: function (schema, candidate) {\n      if (String(schema.validDate) === 'true' && candidate instanceof Date && isNaN(candidate.getTime())) {\n        this.report('must be a valid date', null, 'validDate');\n      }\n    },\n    minLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var minLength = Number(schema.minLength);\n      if (isNaN(minLength)) {\n        return;\n      }\n      if (candidate.length < minLength) {\n        this.report('must be longer than ' + minLength + ' elements, but it has ' + candidate.length, null, 'minLength');\n      }\n    },\n    maxLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var maxLength = Number(schema.maxLength);\n      if (isNaN(maxLength)) {\n        return;\n      }\n      if (candidate.length > maxLength) {\n        this.report('must be shorter than ' + maxLength + ' elements, but it has ' + candidate.length, null, 'maxLength');\n      }\n    },\n    exactLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var exactLength = Number(schema.exactLength);\n      if (isNaN(exactLength)) {\n        return;\n      }\n      if (candidate.length !== exactLength) {\n        this.report('must have exactly ' + exactLength + ' elements, but it have ' + candidate.length, null, 'exactLength');\n      }\n    },\n    lt: function (schema, candidate) {\n      var limit = Number(schema.lt);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate >= limit) {\n        this.report('must be less than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lt');\n      }\n    },\n    lte: function (schema, candidate) {\n      var limit = Number(schema.lte);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate > limit) {\n        this.report('must be less than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lte');\n      }\n    },\n    gt: function (schema, candidate) {\n      var limit = Number(schema.gt);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate <= limit) {\n        this.report('must be greater than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gt');\n      }\n    },\n    gte: function (schema, candidate) {\n      var limit = Number(schema.gte);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate < limit) {\n        this.report('must be greater than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gte');\n      }\n    },\n    eq: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string' && typeof candidate !== 'boolean') {\n        return;\n      }\n      var limit = schema.eq;\n      if (typeof limit !== 'number' && typeof limit !== 'string' && typeof limit !== 'boolean' && !_typeIs.array(limit)) {\n        return;\n      }\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            return;\n          }\n        }\n        this.report('must be equal to [' + limit.map(function (l) {\n          return '\"' + l + '\"';\n        }).join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'eq');\n      } else {\n        if (candidate !== limit) {\n          this.report('must be equal to \"' + limit + '\", but is equal to \"' + candidate + '\"', null, 'eq');\n        }\n      }\n    },\n    ne: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string') {\n        return;\n      }\n      var limit = schema.ne;\n      if (typeof limit !== 'number' && typeof limit !== 'string' && !_typeIs.array(limit)) {\n        return;\n      }\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            this.report('must not be equal to \"' + limit[i] + '\"', null, 'ne');\n            return;\n          }\n        }\n      } else {\n        if (candidate === limit) {\n          this.report('must not be equal to \"' + limit + '\"', null, 'ne');\n        }\n      }\n    },\n    multipleOf: function (schema, candidate) {\n      const divisor = Number(schema.multipleOf);\n      if (typeof candidate !== 'number' || isNaN(divisor)) {\n        return;\n      }\n      if (candidate % divisor !== 0) {\n        this.report(candidate + ' is not divisible by ' + divisor, null, 'multipleOf');\n      }\n    },\n    someKeys: function (schema, candidat) {\n      var _keys = schema.someKeys;\n      if (!_typeIs.object(candidat)) {\n        return;\n      }\n      var valid = _keys.some(function (action) {\n        return (action in candidat);\n      });\n      if (!valid) {\n        this.report('must have at least key ' + _keys.map(function (i) {\n          return '\"' + i + '\"';\n        }).join(' or '), null, 'someKeys');\n      }\n    },\n    strict: function (schema, candidate) {\n      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }\n      if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {\n        return;\n      }\n      var self = this;\n      if (typeof schema.properties['*'] === 'undefined') {\n        var intruder = Object.keys(candidate).filter(function (key) {\n          return (typeof schema.properties[key] === 'undefined');\n        });\n        if (intruder.length > 0) {\n          var msg = 'should not contains ' + (intruder.length > 1 ? 'properties' : 'property') +\n            ' [' + intruder.map(function (i) { return '\"' + i + '\"'; }).join(', ') + ']';\n          self.report(msg, null, 'strict');\n        }\n      }\n    },\n    exec: function (schema, candidate, callback) {\n      var self = this;\n\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, candidate, callback);\n      }\n      (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function (exec) {\n        if (typeof exec === 'function') {\n          exec.call(self, schema, candidate);\n        }\n      });\n    },\n    properties: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, candidate, callback);\n      }\n      if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n      var properties = schema.properties;\n      var i;\n      if (properties['*'] != null) {\n        for (i in candidate) {\n          if (i in properties) {\n            continue;\n          }\n          this._deeperObject(i);\n          this._validate(properties['*'], candidate[i]);\n          this._back();\n        }\n      }\n      for (i in properties) {\n        if (i === '*') {\n          continue;\n        }\n        this._deeperObject(i);\n        this._validate(properties[i], candidate[i]);\n        this._back();\n      }\n    },\n    items: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, candidate, callback);\n      }\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n      var items = schema.items;\n      var i, l;\n      // If provided schema is an array\n      // then call validate for each case\n      // else it is an Object\n      // then call validate for each key\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        for (i = 0, l = items.length; i < l; i++) {\n          this._deeperArray(i);\n          this._validate(items[i], candidate[i]);\n          this._back();\n        }\n      } else {\n        for (var key in candidate) {\n          if (Object.prototype.hasOwnProperty.call(candidate, key)) {\n            this._deeperArray(key);\n            this._validate(items, candidate[key]);\n            this._back();\n          }\n        }\n      }\n    }\n  };\n\n  var _asyncValidationAttribut = {\n    asyncExec: function (schema, candidate, callback) {\n      var self = this;\n      async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, candidate, done);\n          }\n          exec.call(self, schema, candidate);\n        }\n        async.nextTick(done);\n      }, callback);\n    },\n    asyncProperties: function (schema, candidate, callback) {\n      if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {\n        return callback();\n      }\n      var self = this;\n      var properties = schema.properties;\n      async.series([\n        function (next) {\n          if (properties['*'] == null) {\n            return next();\n          }\n          async.eachSeries(Object.keys(candidate), function (i, done) {\n            if (i in properties) {\n              return async.nextTick(done);\n            }\n            self._deeperObject(i);\n            self._asyncValidate(properties['*'], candidate[i], function (err) {\n              self._back();\n              done(err);\n            });\n          }, next);\n        },\n        function (next) {\n          async.eachSeries(Object.keys(properties), function (i, done) {\n            if (i === '*') {\n              return async.nextTick(done);\n            }\n            self._deeperObject(i);\n            self._asyncValidate(properties[i], candidate[i], function (err) {\n              self._back();\n              done(err);\n            });\n          }, next);\n        }\n      ], callback);\n    },\n    asyncItems: function (schema, candidate, callback) {\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return callback();\n      }\n      var self = this;\n      var items = schema.items;\n\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        async.timesSeries(items.length, function (i, done) {\n          self._deeperArray(i);\n          self._asyncValidate(items[i], candidate[i], function (err, res) {\n            self._back();\n            done(err, res);\n          });\n          self._back();\n        }, callback);\n      } else {\n        async.eachSeries(Object.keys(candidate), function (key, done) {\n          self._deeperArray(key);\n          self._asyncValidate(items, candidate[key], function (err, res) {\n            self._back();\n            done(err, res);\n          });\n        }, callback);\n      }\n    }\n  };\n\n  // Validation Class ----------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n  function Validation(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));\n    var _error = [];\n\n    this._basicFields = Object.keys(_validationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message, code, reason) {\n      var newErr = {\n        code: code || this.userCode || null,\n        reason: reason || 'unknown',\n        message: this.userError || message || 'is invalid',\n        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()\n      };\n      _error.push(newErr);\n      return this;\n    };\n\n    this.result = function () {\n      return {\n        error: _error,\n        valid: _error.length === 0,\n        format: function () {\n          if (this.valid === true) {\n            return 'Candidate is valid';\n          }\n          return this.error.map(function (i) {\n            return 'Property ' + i.property + ': ' + i.message;\n          }).join('\\n');\n        }\n      };\n    };\n  }\n\n  _extend(Validation.prototype, _validationAttribut);\n  _extend(Validation.prototype, _asyncValidationAttribut);\n  _extend(Validation, new Customisable());\n\n  Validation.prototype.validate = function (candidate, callback) {\n    this.origin = candidate;\n    if (typeof callback === 'function') {\n      var self = this;\n      return async.nextTick(function () {\n        self._asyncValidate(self._schema, candidate, function (err) {\n          self.origin = null;\n          callback(err, self.result());\n        });\n      });\n    }\n    return this._validate(this._schema, candidate).result();\n  };\n\n  Validation.prototype._validate = function (schema, candidate, callback) {\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        this[i](schema, candidate);\n      }\n    }, this);\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        this._custom[i].call(this, schema, candidate);\n      }\n    }, this);\n    return this;\n  };\n\n  Validation.prototype._asyncValidate = function (schema, candidate, callback) {\n    var self = this;\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n\n    async.series([\n      function (next) {\n        async.eachSeries(Object.keys(_validationAttribut), function (i, done) {\n          async.nextTick(function () {\n            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n              if (self[i].length > 2) {\n                return self[i](schema, candidate, done);\n              }\n              self[i](schema, candidate);\n            }\n            done();\n          });\n        }, next);\n      },\n      function (next) {\n        async.eachSeries(Object.keys(self._custom), function (i, done) {\n          async.nextTick(function () {\n            if (i in schema && typeof self._custom[i] === 'function') {\n              if (self._custom[i].length > 2) {\n                return self._custom[i].call(self, schema, candidate, done);\n              }\n              self._custom[i].call(self, schema, candidate);\n            }\n            done();\n          });\n        }, next);\n      }\n    ], callback);\n  };\n\n  // Sanitization ----------------------------------------------------------------\n  // functions called by _sanitization.type method.\n  var _forceType = {\n    number: function (post, schema) {\n      var n;\n      if (typeof post === 'number') {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') {\n          return schema.def;\n        }\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (post instanceof Date) {\n        return +post;\n      }\n      return null;\n    },\n    integer: function (post, schema) {\n      var n;\n      if (typeof post === 'number' && post % 1 === 0) {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') {\n          return schema.def;\n        }\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseInt(post.replace(/ /g, ''), 10);\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (typeof post === 'number') {\n        return parseInt(post, 10);\n      } else if (typeof post === 'boolean') {\n        if (post) { return 1; }\n        return 0;\n      } else if (post instanceof Date) {\n        return +post;\n      }\n      return null;\n    },\n    string: function (post, schema) {\n      if (typeof post === 'boolean' || typeof post === 'number' || post instanceof Date) {\n        return post.toString();\n      } else if (_typeIs.array(post)) {\n        // If user authorize array and strings...\n        if (schema.items || schema.properties) {\n          return post;\n        }\n        return post.join(String(schema.joinWith || ','));\n      } else if (post instanceof Object) {\n        // If user authorize objects ans strings...\n        if (schema.items || schema.properties) {\n          return post;\n        }\n        return JSON.stringify(post);\n      } else if (typeof post === 'string' && post.length) {\n        return post;\n      }\n      return null;\n    },\n    date: function (post, schema) {\n      if (post instanceof Date) {\n        return post;\n      } else {\n        var d = new Date(post);\n        if (!isNaN(d.getTime())) { // if valid date\n          return d;\n        }\n      }\n      return null;\n    },\n    boolean: function (post, schema) {\n      if (typeof post === 'undefined') return null;\n      if (typeof post === 'string' && post.toLowerCase() === 'false') return false;\n      return !!post;\n    },\n    object: function (post, schema) {\n      if (typeof post !== 'string' || _typeIs.object(post)) {\n        return post;\n      }\n      try {\n        return JSON.parse(post);\n      } catch (e) {\n        return null;\n      }\n    },\n    array: function (post, schema) {\n      if (_typeIs.array(post)) {\n        return post;\n      }\n      if (typeof post === 'undefined') {\n        return null;\n      }\n      if (typeof post === 'string') {\n        if (post.substring(0, 1) === '[' && post.slice(-1) === ']') {\n          try {\n            return JSON.parse(post);\n          } catch (e) {\n            return null;\n          }\n        }\n        return post.split(String(schema.splitWith || ','));\n      }\n      if (!_typeIs.array(post)) {\n        return [post];\n      }\n      return null;\n    }\n  };\n\n  var _applyRules = {\n    upper: function (post) {\n      return post.toUpperCase();\n    },\n    lower: function (post) {\n      return post.toLowerCase();\n    },\n    title: function (post) {\n      // Fix by seb (replace \\w\\S* by \\S* => exemple : coucou Ã§a va)\n      return post.replace(/\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n      });\n    },\n    capitalize: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();\n    },\n    ucfirst: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1);\n    },\n    trim: function (post) {\n      return post.trim();\n    }\n  };\n\n  // Every function return the future value of each property. Therefore you\n  // have to return post even if you do not change its value\n  var _sanitizationAttribut = {\n    strict: function (schema, post) {\n      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }\n      if (schema.strict !== true) {\n        return post;\n      }\n      if (!_typeIs.object(schema.properties)) {\n        return post;\n      }\n      if (!_typeIs.object(post)) {\n        return post;\n      }\n      Object.keys(post).forEach(function (key) {\n        if (!(key in schema.properties)) {\n          delete post[key];\n        }\n      });\n      return post;\n    },\n    optional: function (schema, post) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional !== 'false'); // Default: true\n      if (opt === true) {\n        return post;\n      }\n      if (typeof post !== 'undefined') {\n        return post;\n      }\n      this.report();\n      if (schema.def === Date) {\n        return new Date();\n      }\n      return schema.def;\n    },\n    type: function (schema, post) {\n      // if (_typeIs['object'](post) || _typeIs.array(post)) {\n      //   return post;\n      // }\n      if (typeof schema.type !== 'string' || typeof _forceType[schema.type] !== 'function') {\n        return post;\n      }\n      var n;\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : true;\n      if (typeof _forceType[schema.type] === 'function') {\n        n = _forceType[schema.type](post, schema);\n        if ((n === null && !opt) || (!n && isNaN(n)) || (n === null && schema.type === 'string')) {\n          n = schema.def;\n        }\n      } else if (!opt) {\n        n = schema.def;\n      }\n      if ((n != null || (typeof schema.def !== 'undefined' && schema.def === n)) && n !== post) {\n        this.report();\n        return n;\n      }\n      return post;\n    },\n    rules: function (schema, post) {\n      var rules = schema.rules;\n      if (typeof post !== 'string' || (typeof rules !== 'string' && !_typeIs.array(rules))) {\n        return post;\n      }\n      var modified = false;\n      (_typeIs.array(rules) ? rules : [rules]).forEach(function (rule) {\n        if (typeof _applyRules[rule] === 'function') {\n          post = _applyRules[rule](post);\n          modified = true;\n        }\n      });\n      if (modified) {\n        this.report();\n      }\n      return post;\n    },\n    min: function (schema, post) {\n      var postTest = Number(post);\n      if (isNaN(postTest)) {\n        return post;\n      }\n      var min = Number(schema.min);\n      if (isNaN(min)) {\n        return post;\n      }\n      if (postTest < min) {\n        this.report();\n        return min;\n      }\n      return post;\n    },\n    max: function (schema, post) {\n      var postTest = Number(post);\n      if (isNaN(postTest)) {\n        return post;\n      }\n      var max = Number(schema.max);\n      if (isNaN(max)) {\n        return post;\n      }\n      if (postTest > max) {\n        this.report();\n        return max;\n      }\n      return post;\n    },\n    minLength: function (schema, post) {\n      var limit = Number(schema.minLength);\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n      var str = '';\n      var gap = limit - post.length;\n      if (gap > 0) {\n        for (var i = 0; i < gap; i++) {\n          str += '-';\n        }\n        this.report();\n        return post + str;\n      }\n      return post;\n    },\n    maxLength: function (schema, post) {\n      var limit = Number(schema.maxLength);\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n      if (post.length > limit) {\n        this.report();\n        return post.slice(0, limit);\n      }\n      return post;\n    },\n    properties: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, post, callback);\n      }\n      if (!post || typeof post !== 'object') {\n        return post;\n      }\n      var properties = schema.properties;\n      var tmp;\n      var i;\n      if (typeof properties['*'] !== 'undefined') {\n        for (i in post) {\n          if (i in properties) {\n            continue;\n          }\n          this._deeperObject(i);\n          tmp = this._sanitize(properties['*'], post[i]);\n          if (typeof tmp !== 'undefined' || 'exec' in properties['*']) {\n            post[i] = tmp;\n          }\n          this._back();\n        }\n      }\n      for (i in properties) {\n        if (i !== '*') {\n          this._deeperObject(i);\n          tmp = this._sanitize(properties[i], post[i]);\n          if (typeof tmp !== 'undefined' || 'exec' in properties[i]) {\n            post[i] = tmp;\n          }\n          this._back();\n        }\n      }\n      return post;\n    },\n    items: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, post, callback);\n      }\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return post;\n      }\n      var i;\n      if (_typeIs.array(schema.items) && _typeIs.array(post)) {\n        var minLength = schema.items.length < post.length ? schema.items.length : post.length;\n        for (i = 0; i < minLength; i++) {\n          this._deeperArray(i);\n          post[i] = this._sanitize(schema.items[i], post[i]);\n          this._back();\n        }\n      } else {\n        for (i in post) {\n          if (Object.prototype.hasOwnProperty.call(post, i)) {\n            this._deeperArray(i);\n            post[i] = this._sanitize(schema.items, post[i]);\n            this._back();\n          }\n        }\n      }\n      return post;\n    },\n    exec: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, post, callback);\n      }\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n\n      execs.forEach(function (exec) {\n        if (typeof exec === 'function') {\n          post = exec.call(this, schema, post);\n        }\n      }, this);\n      return post;\n    }\n  };\n\n  var _asyncSanitizationAttribut = {\n    asyncExec: function (schema, post, callback) {\n      var self = this;\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n\n      async.eachSeries(execs, function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, post, function (err, res) {\n              if (err) {\n                return done(err);\n              }\n              post = res;\n              done();\n            });\n          }\n          post = exec.call(self, schema, post);\n        }\n        done();\n      }, function (err) {\n        callback(err, post);\n      });\n    },\n    asyncProperties: function (schema, post, callback) {\n      if (!post || typeof post !== 'object') {\n        return callback(null, post);\n      }\n      var self = this;\n      var properties = schema.properties;\n\n      async.series([\n        function (next) {\n          if (properties['*'] == null) {\n            return next();\n          }\n          var globing = properties['*'];\n          async.eachSeries(Object.keys(post), function (i, next) {\n            if (i in properties) {\n              return next();\n            }\n            self._deeperObject(i);\n            self._asyncSanitize(globing, post[i], function (err, res) {\n              if (err) { /* Error can safely be ignored here */ }\n              if (typeof res !== 'undefined') {\n                post[i] = res;\n              }\n              self._back();\n              next();\n            });\n          }, next);\n        },\n        function (next) {\n          async.eachSeries(Object.keys(properties), function (i, next) {\n            if (i === '*') {\n              return next();\n            }\n            self._deeperObject(i);\n            self._asyncSanitize(properties[i], post[i], function (err, res) {\n              if (err) {\n                return next(err);\n              }\n              if (typeof res !== 'undefined') {\n                post[i] = res;\n              }\n              self._back();\n              next();\n            });\n          }, next);\n        }\n      ], function (err) {\n        return callback(err, post);\n      });\n    },\n    asyncItems: function (schema, post, callback) {\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return callback(null, post);\n      }\n      var self = this;\n      var items = schema.items;\n      if (_typeIs.array(items) && _typeIs.array(post)) {\n        var minLength = items.length < post.length ? items.length : post.length;\n        async.timesSeries(minLength, function (i, next) {\n          self._deeperArray(i);\n          self._asyncSanitize(items[i], post[i], function (err, res) {\n            if (err) {\n              return next(err);\n            }\n            post[i] = res;\n            self._back();\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      } else {\n        async.eachSeries(Object.keys(post), function (key, next) {\n          self._deeperArray(key);\n          self._asyncSanitize(items, post[key], function (err, res) {\n            if (err) {\n              return next();\n            }\n            post[key] = res;\n            self._back();\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      }\n      return post;\n    }\n  };\n\n  // Sanitization Class --------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n  function Sanitization(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));\n    var _reporting = [];\n\n    this._basicFields = Object.keys(_sanitizationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message) {\n      var newNot = {\n        message: message || 'was sanitized',\n        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()\n      };\n      if (!_reporting.some(function (e) { return e.property === newNot.property; })) {\n        _reporting.push(newNot);\n      }\n    };\n\n    this.result = function (data) {\n      // For old IE.\n      /* eslint-disable object-shorthand */\n      return {\n        data: data,\n        reporting: _reporting,\n        format: function () {\n          return this.reporting.map(function (i) {\n            return 'Property ' + i.property + ' ' + i.message;\n          }).join('\\n');\n        }\n      };\n      /* eslint-enable object-shorthand */\n    };\n  }\n\n  _extend(Sanitization.prototype, _sanitizationAttribut);\n  _extend(Sanitization.prototype, _asyncSanitizationAttribut);\n  _extend(Sanitization, new Customisable());\n\n  Sanitization.prototype.sanitize = function (post, callback) {\n    this.origin = post;\n    if (typeof callback === 'function') {\n      var self = this;\n      return this._asyncSanitize(this._schema, post, function (err, data) {\n        self.origin = null;\n        callback(err, self.result(data));\n      });\n    }\n    var data = this._sanitize(this._schema, post);\n    this.origin = null;\n    return this.result(data);\n  };\n\n  Sanitization.prototype._sanitize = function (schema, post) {\n    this.userAlias = schema.alias || null;\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        post = this[i](schema, post);\n      }\n    }, this);\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        post = this._custom[i].call(this, schema, post);\n      }\n    }, this);\n    return post;\n  };\n\n  Sanitization.prototype._asyncSanitize = function (schema, post, callback) {\n    var self = this;\n    this.userAlias = schema.alias || null;\n\n    async.waterfall([\n      function (next) {\n        async.reduce(self._basicFields, post, function (value, i, next) {\n          async.nextTick(function () {\n            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n              if (self[i].length > 2) {\n                return self[i](schema, value, next);\n              }\n              value = self[i](schema, value);\n            }\n            next(null, value);\n          });\n        }, next);\n      },\n      function (inter, next) {\n        async.reduce(self._customFields, inter, function (value, i, next) {\n          async.nextTick(function () {\n            if (i in schema && typeof self._custom[i] === 'function') {\n              if (self._custom[i].length > 2) {\n                return self._custom[i].call(self, schema, value, next);\n              }\n              value = self._custom[i].call(self, schema, value);\n            }\n            next(null, value);\n          });\n        }, next);\n      }\n    ], callback);\n  };\n\n  // ---------------------------------------------------------------------------\n\n  var INT_MIN = -2147483648;\n  var INT_MAX = 2147483647;\n\n  var _rand = {\n    int: function (min, max) {\n      return min + (0 | Math.random() * (max - min + 1));\n    },\n    float: function (min, max) {\n      return (Math.random() * (max - min) + min);\n    },\n    bool: function () {\n      return (Math.random() > 0.5);\n    },\n    char: function (min, max) {\n      return String.fromCharCode(this.int(min, max));\n    },\n    fromList: function (list) {\n      return list[this.int(0, list.length - 1)];\n    }\n  };\n\n  var _formatSample = {\n    'date-time': function () {\n      return new Date().toISOString();\n    },\n    date: function () {\n      return new Date().toISOString().replace(/T.*$/, '');\n    },\n    time: function () {\n      return new Date().toLocaleTimeString({}, { hour12: false });\n    },\n    color: function (min, max) {\n      var s = '#';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('0123456789abcdefABCDEF');\n      }\n      return s;\n    },\n    numeric: function () {\n      return '' + _rand.int(0, INT_MAX);\n    },\n    integer: function () {\n      if (_rand.bool() === true) {\n        return '-' + this.numeric();\n      }\n      return this.numeric();\n    },\n    decimal: function () {\n      return this.integer() + '.' + this.numeric();\n    },\n    alpha: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');\n      }\n      return s;\n    },\n    alphaNumeric: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n      }\n      return s;\n    },\n    alphaDash: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-');\n      }\n      return s;\n    },\n    javascript: function (min, max) {\n      var s = _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$');\n      for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {\n        s += _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$');\n      }\n      return s;\n    }\n  };\n\n  function _getLimits(schema) {\n    var min = INT_MIN;\n    var max = INT_MAX;\n\n    if (schema.gte != null) {\n      min = schema.gte;\n    } else if (schema.gt != null) {\n      min = schema.gt + 1;\n    }\n    if (schema.lte != null) {\n      max = schema.lte;\n    } else if (schema.lt != null) {\n      max = schema.lt - 1;\n    }\n    // For old IE.\n    /* eslint-disable object-shorthand */\n    return { min: min, max: max };\n    /* eslint-enable object-shorthand */\n  }\n\n  var _typeGenerator = {\n    string: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var s = '';\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 32;\n      if (typeof schema.pattern === 'string' && typeof _formatSample[schema.pattern] === 'function') {\n        return _formatSample[schema.pattern](minLength, maxLength);\n      }\n\n      var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n      for (var i = 0; i < l; i++) {\n        s += _rand.char(32, 126);\n      }\n      return s;\n    },\n    number: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var limit = _getLimits(schema);\n      var n = _rand.float(limit.min, limit.max);\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.float(limit.min, limit.max);\n        }\n      }\n      return n;\n    },\n    integer: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var limit = _getLimits(schema);\n      var n = _rand.int(limit.min, limit.max);\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.int(limit.min, limit.max);\n        }\n      }\n      return n;\n    },\n    boolean: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      return _rand.bool();\n    },\n    null: function (schema) {\n      return null;\n    },\n    date: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      return new Date();\n    },\n    object: function (schema) {\n      var o = {};\n      var prop = schema.properties || {};\n\n      for (var key in prop) {\n        if (Object.prototype.hasOwnProperty.call(prop, key)) {\n          if (prop[key].optional === true && _rand.bool() === true) {\n            continue;\n          }\n          if (key !== '*') {\n            o[key] = this.generate(prop[key]);\n          } else {\n            var rk = '__random_key_';\n            var randomKey = rk + 0;\n            var n = _rand.int(1, 9);\n            for (var i = 1; i <= n; i++) {\n              if (!(randomKey in prop)) {\n                o[randomKey] = this.generate(prop[key]);\n              }\n              randomKey = rk + i;\n            }\n          }\n        }\n      }\n      return o;\n    },\n    array: function (schema) {\n      var self = this;\n      var items = schema.items || {};\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 16;\n      var type;\n      var candidate;\n      var size;\n      var i;\n\n      if (_typeIs.array(items)) {\n        size = items.length;\n        if (schema.exactLength != null) {\n          size = schema.exactLength;\n        } else if (size < minLength) {\n          size = minLength;\n        } else if (size > maxLength) {\n          size = maxLength;\n        }\n        candidate = new Array(size);\n        type = null;\n        for (i = 0; i < size; i++) {\n          type = items[i].type || 'any';\n          if (_typeIs.array(type)) {\n            type = type[_rand.int(0, type.length - 1)];\n          }\n          candidate[i] = self[type](items[i]);\n        }\n      } else {\n        size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n        candidate = new Array(size);\n        type = items.type || 'any';\n        if (_typeIs.array(type)) {\n          type = type[_rand.int(0, type.length - 1)];\n        }\n        for (i = 0; i < size; i++) {\n          candidate[i] = self[type](items);\n        }\n      }\n      return candidate;\n    },\n    any: function (schema) {\n      var fields = Object.keys(_typeGenerator);\n      var i = fields[_rand.int(0, fields.length - 2)];\n      return this[i](schema);\n    }\n  };\n\n  // CandidateGenerator Class (Singleton) --------------------------------------\n  function CandidateGenerator() {\n    // Maybe extends Inspection class too ?\n  }\n\n  _extend(CandidateGenerator.prototype, _typeGenerator);\n\n  var _instance = null;\n  CandidateGenerator.instance = function () {\n    if (!(_instance instanceof CandidateGenerator)) {\n      _instance = new CandidateGenerator();\n    }\n    return _instance;\n  };\n\n  CandidateGenerator.prototype.generate = function (schema) {\n    var type = schema.type || 'any';\n    if (_typeIs.array(type)) {\n      type = type[_rand.int(0, type.length - 1)];\n    }\n    return this[type](schema);\n  };\n\n  // Exports ---------------------------------------------------------------------\n  var SchemaInspector = {};\n\n  // if server-side (node.js) else client-side\n  if ( true && module.exports) {\n    module.exports = SchemaInspector;\n  } else {\n    window.SchemaInspector = SchemaInspector;\n  }\n\n  SchemaInspector.newSanitization = function (schema, custom) {\n    return new Sanitization(schema, custom);\n  };\n\n  SchemaInspector.newValidation = function (schema, custom) {\n    return new Validation(schema, custom);\n  };\n\n  SchemaInspector.Validation = Validation;\n  SchemaInspector.Sanitization = Sanitization;\n\n  SchemaInspector.sanitize = function (schema, post, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n    return new Sanitization(schema, custom).sanitize(post, callback);\n  };\n\n  SchemaInspector.validate = function (schema, candidate, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n    return new Validation(schema, custom).validate(candidate, callback);\n  };\n\n  SchemaInspector.generate = function (schema, n) {\n    if (typeof n === 'number') {\n      var r = new Array(n);\n      for (var i = 0; i < n; i++) {\n        r[i] = CandidateGenerator.instance().generate(schema);\n      }\n      return r;\n    }\n    return CandidateGenerator.instance().generate(schema);\n  };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9saWIvc2NoZW1hLWluc3BlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBNkIsSUFBSSxtQkFBTyxDQUFDLHVEQUFPLElBQUksQ0FBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qyx1REFBdUQ7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxFQUFFLGtCQUFrQixrckJBQWtyQixFQUFFLGtCQUFrQixvRkFBb0YsRUFBRSxrQkFBa0IsMkZBQTJGLEVBQUUsa0JBQWtCLDhHQUE4RyxFQUFFLGtCQUFrQjtBQUMxcEMsc0JBQXNCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLElBQUksRUFBRTtBQUNyRixlQUFlLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3Qix1QkFBdUIsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUM3RSxlQUFlLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUNBQXlDLGtFQUFrRTtBQUMzRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQXdDO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsSUFBSSxlQUFlO0FBQ2hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBNkI7QUFDbkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXE5hbWFuIFNpbmdodmkgUGVyc29uYWxcXEhhcnZhcmQgSGFja2F0aG9uXFxmaXRCVENcXGZpdEJUQyBtYWluXFxub2RlX21vZHVsZXNcXHNjaGVtYS1pbnNwZWN0b3JcXGxpYlxcc2NoZW1hLWluc3BlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEaXNhYmxlIG5vLXZhciBiZWNhdXNlIHdlIG5lZWQgdG8gc3VwcG9ydCBvbGQgSUUgZm9yIG5vdy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gRGlzYWJsZSBzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW4gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBWUyBDb2RlIGRlZmF1bHQgSlMgZm9ybWF0dGVyLlxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuICovXG5cbi8qXG4gKiBUaGlzIG1vZHVsZSBpcyBpbnRlbmRlZCB0byBiZSBleGVjdXRlZCBib3RoIG9uIGNsaWVudCBzaWRlIGFuZCBzZXJ2ZXIgc2lkZS5cbiAqIE5vIGVycm9yIHNob3VsZCBiZSB0aHJvd24uIChzb2Z0IGVycm9yIGhhbmRsaW5nKVxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciByb290ID0ge307XG4gIC8vIERlcGVuZGVuY2llcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByb290LmFzeW5jID0gKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSA/IHJlcXVpcmUoJ2FzeW5jJykgOiB3aW5kb3cuYXN5bmM7XG4gIGlmICh0eXBlb2Ygcm9vdC5hc3luYyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSBhc3luYyBpcyByZXF1aXJlZCAoaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luYyknKTtcbiAgfVxuICB2YXIgYXN5bmMgPSByb290LmFzeW5jO1xuXG4gIGZ1bmN0aW9uIF9leHRlbmQob3JpZ2luLCBhZGQpIHtcbiAgICBpZiAoIWFkZCB8fCB0eXBlb2YgYWRkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luO1xuICB9XG5cbiAgZnVuY3Rpb24gX21lcmdlKCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGtleXMgPSBudWxsO1xuICAgIHZhciBpID0gbnVsbDtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBpZiAoYXJnICYmIGFyZy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICByZXRba2V5c1tpXV0gPSBhcmdba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQ3VzdG9taXNhYmxlIGNsYXNzIChCYXNlIGNsYXNzKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFVzZSB3aXRoIG9wZXJhdGlvbiBcIm5ld1wiIHRvIGV4dGVuZCBWYWxpZGF0aW9uIGFuZCBTYW5pdGl6YXRpb24gdGhlbXNlbHZlcyxcbiAgLy8gbm90IHRoZWlyIHByb3RvdHlwZS4gSW4gb3RoZXIgd29yZHMsIGNvbnN0cnVjdG9yIHNoYWxsIGJlIGNhbGwgdG8gZXh0ZW5kXG4gIC8vIHRob3NlIGZ1bmN0aW9ucywgaW5zdGVhZCBvZiBiZWluZyBpbiB0aGVpciBjb25zdHJ1Y3RvciwgbGlrZSB0aGlzOlxuICAvLyAgIF9leHRlbmQoVmFsaWRhdGlvbiwgbmV3IEN1c3RvbWlzYWJsZSk7XG5cbiAgZnVuY3Rpb24gQ3VzdG9taXNhYmxlKCkge1xuICAgIHRoaXMuY3VzdG9tID0ge307XG5cbiAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uIChjdXN0b20pIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kKHRoaXMuY3VzdG9tLCBjdXN0b20pO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jdXN0b20gPSB7fTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoZmllbGRzKSB7XG4gICAgICBpZiAoIV90eXBlSXMuYXJyYXkoZmllbGRzKSkge1xuICAgICAgICBmaWVsZHMgPSBbZmllbGRzXTtcbiAgICAgIH1cbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5jdXN0b21bZmllbGRdO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEluc3BlY3Rpb24gY2xhc3MgKEJhc2UgY2xhc3MpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBVc2UgdG8gZXh0ZW5kIFZhbGlkYXRpb24gYW5kIFNhbml0aXphdGlvbiBwcm90b3R5cGVzLiBJbnNwZWN0aW9uXG4gIC8vIGNvbnN0cnVjdG9yIHNoYWxsIGJlIGNhbGxlZCBpbiBkZXJpdmVkIGNsYXNzIGNvbnN0cnVjdG9yLlxuXG4gIGZ1bmN0aW9uIEluc3BlY3Rpb24oc2NoZW1hLCBjdXN0b20pIHtcbiAgICB2YXIgX3N0YWNrID0gWydAJ107XG5cbiAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5fY3VzdG9tID0ge307XG4gICAgaWYgKGN1c3RvbSAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gY3VzdG9tKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VzdG9tLCBrZXkpKSB7XG4gICAgICAgICAgdGhpcy5fY3VzdG9tWyckJyArIGtleV0gPSBjdXN0b21ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2dldERlcHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9zdGFjay5sZW5ndGg7XG4gICAgfTtcblxuICAgIHRoaXMuX2R1bXBTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cbiAgICAgIHJldHVybiBfc3RhY2subWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnJlcGxhY2UoL15cXFsvZywgJ1xcdTAwMWJcXHUwMDFjXFx1MDAxZFxcdTAwMWUnKTsgfSlcbiAgICAgICAgLmpvaW4oJy4nKS5yZXBsYWNlKC9cXC5cXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlL2csICdbJyk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cbiAgICB9O1xuXG4gICAgdGhpcy5fZGVlcGVyT2JqZWN0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF9zdGFjay5wdXNoKCgvXlthLXokX11bYS16MC05JF9dKiQvaSkudGVzdChuYW1lKSA/IG5hbWUgOiAnW1wiJyArIG5hbWUgKyAnXCJdJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5fZGVlcGVyQXJyYXkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgX3N0YWNrLnB1c2goJ1snICsgaSArICddJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5fYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9zdGFjay5wb3AoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbiAgLy8gU2ltcGxlIHR5cGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZCBvciBpcyBub3QgaW4gdGhpcyBsaXN0OlxuICB2YXIgX3R5cGVJcyA9IHtcbiAgICBmdW5jdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZyc7XG4gICAgfSxcbiAgICBudW1iZXI6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInICYmICFpc05hTihlbGVtZW50KTtcbiAgICB9LFxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInICYmIGVsZW1lbnQgJSAxID09PSAwO1xuICAgIH0sXG4gICAgTmFOOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJyAmJiBpc05hTihlbGVtZW50KTtcbiAgICB9LFxuICAgIGJvb2xlYW46IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdib29sZWFuJztcbiAgICB9LFxuICAgIG51bGw6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbDtcbiAgICB9LFxuICAgIGRhdGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBEYXRlO1xuICAgIH0sXG4gICAgb2JqZWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC5jb25zdHJ1Y3RvciAhPT0gQXJyYXk7XG4gICAgfSxcbiAgICBhcnJheTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBfc2ltcGxlVHlwZSh0eXBlLCBjYW5kaWRhdGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjYW5kaWRhdGUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgICB0eXBlID0gdHlwZSBpbiBfdHlwZUlzID8gdHlwZSA6ICdhbnknO1xuICAgIHJldHVybiBfdHlwZUlzW3R5cGVdKGNhbmRpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfcmVhbFR5cGUoY2FuZGlkYXRlKSB7XG4gICAgZm9yICh2YXIgaSBpbiBfdHlwZUlzKSB7XG4gICAgICBpZiAoX3NpbXBsZVR5cGUoaSwgY2FuZGlkYXRlKSkge1xuICAgICAgICBpZiAoaSAhPT0gJ2FueScgJiYgKGkgIT09ICdvYmplY3QnIHx8IGNhbmRpZGF0ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkgeyByZXR1cm4gaTsgfVxuICAgICAgICByZXR1cm4gJ2FuIGluc3RhbmNlIG9mICcgKyBjYW5kaWRhdGUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbmRleGVzKGEsIHZhbHVlKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICB2YXIgaSA9IGEuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICB3aGlsZSAoaSAhPT0gLTEpIHtcbiAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgIGkgPSBhLmluZGV4T2YodmFsdWUsIGkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvLyBBdmFpbGFibGUgZm9ybWF0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbiAgLy8gVE9ETzogU3R1ZHkgdGhlc2UgcmVnZXggZXhwcmVzc2lvbnMgYW5kIGFkZCBtb3JlIHRlc3RzIHNvIHdlIGNhbiBjb25zaWRlciByZW1vdmluZ1xuICAvLyBydWxlIG5vLXVzZWxlc3MtZXNjYXBlLlxuICB2YXIgX2Zvcm1hdHMgPSB7XG4gICAgdm9pZDogL14kLyxcbiAgICB1cmw6IC9eKGh0dHBzP3xmdHApOlxcL1xcLygoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6KSpAKT8oKChcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSkpfCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pPygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC9pLFxuICAgICdkYXRlLXRpbWUnOiAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZHszfSk/KFo/fCgtfFxcKylcXGR7Mn06XFxkezJ9KSQvLFxuICAgIGRhdGU6IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLyxcbiAgICBjb29sRGF0ZVRpbWU6IC9eXFxkezR9KC18XFwvKVxcZHsyfSgtfFxcLylcXGR7Mn0oVHwgKVxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZHszfSk/Wj8kLyxcbiAgICB0aW1lOiAvXlxcZHsyfVxcOlxcZHsyfVxcOlxcZHsyfSQvLFxuICAgIGNvbG9yOiAvXiMoWzAtOWEtZl0pKyQvaSxcbiAgICAvLyBWZXJ5IGZsZXhpYmxlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXNpZ25lZCB0byBjYXRjaCBvbmx5IG9idmlvdXMgbWlzdGFrZXNcbiAgICAvLyB0aGF0IGEgdXNlciBtaWdodCBtYWtlIHRoYXQgd291bGQgaGF2ZSBhIDEwMCUgY2hhbmNlIG9mIGNhdXNpbmcgZW1haWxcbiAgICAvLyBkZWxpdmVyeSB0byB0aGUgYWRkcmVzcyB0byBmYWlsLiBUaGUgbGlicmFyeSB0YWtlcyBhIGZsZXhpYmxlIG92ZXJcbiAgICAvLyBzdHJpY3QgYXBwcm9hY2guIFVzZXJzIHNob3VsZCB1c2UgdGhpcyBvbmx5IGZvciBiYXNpYyBmcm9udCBlbmQgZW1haWxcbiAgICAvLyBhZGRyZXNzIHZhbGlkYXRpb24gYW5kIHBlcmZvcm0gbW9yZSBzdHJpY3QgY2hlY2tpbmcgdXNpbmcgc2VydmVyLXNpZGVcbiAgICAvLyBjb2RlIGFmdGVyIHRoZSBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlaXIgc2VydmVyLlxuICAgIC8vIFNvdXJjZWQgZnJvbSBodHRwczovL3d3dy5yZWd1bGFyLWV4cHJlc3Npb25zLmluZm8vZW1haWwuaHRtbCwgbW9kaWZpZWRcbiAgICAvLyB0byBhbGxvdyBsb3dlcmNhc2UgY2hhcmFjdGVycyB0b28uXG4gICAgZW1haWw6IC9eW15AXStAW14uXStcXC5bYS16QS1aXSskLyxcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1yZWdleC1saXRlcmFscyAqL1xuICAgIC8qIGVzbGludC1lbmFibGUgcXVvdGVzICovXG4gICAgbnVtZXJpYzogL15bMC05XSskLyxcbiAgICBpbnRlZ2VyOiAvXlxcLT9bMC05XSskLyxcbiAgICBkZWNpbWFsOiAvXlxcLT9bMC05XSpcXC4/WzAtOV0rJC8sXG4gICAgYWxwaGE6IC9eW2Etel0rJC9pLFxuICAgIGFscGhhTnVtZXJpYzogL15bYS16MC05XSskL2ksXG4gICAgYWxwaGFEYXNoOiAvXlthLXowLTlfLV0rJC9pLFxuICAgIGphdmFzY3JpcHQ6IC9eW2Etel9cXCRdW2EtejAtOV9cXCRdKiQvaSxcbiAgICB1cHBlclN0cmluZzogL15bQS1aIF0qJC8sXG4gICAgbG93ZXJTdHJpbmc6IC9eW2EteiBdKiQvLFxuICAgIHY0dXVpZDogL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaVxuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG5cbiAgLy8gVmFsaWRhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIF92YWxpZGF0aW9uQXR0cmlidXQgPSB7XG4gICAgb3B0aW9uYWw6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgdmFyIG9wdCA9IHR5cGVvZiBzY2hlbWEub3B0aW9uYWwgPT09ICdib29sZWFuJyA/IHNjaGVtYS5vcHRpb25hbCA6IChzY2hlbWEub3B0aW9uYWwgPT09ICd0cnVlJyk7IC8vIERlZmF1bHQgaXMgZmFsc2VcblxuICAgICAgaWYgKG9wdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ2lzIG1pc3NpbmcgYW5kIG5vdCBvcHRpb25hbCcsIG51bGwsICdvcHRpb25hbCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICAvLyByZXR1cm4gYmVjYXVzZSBvcHRpb25hbCBmdW5jdGlvbiBhbHJlYWR5IGhhbmRsZSB0aGlzIGNhc2VcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCAodHlwZW9mIHNjaGVtYS50eXBlICE9PSAnc3RyaW5nJyAmJiAhKHNjaGVtYS50eXBlIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBzY2hlbWEudHlwZSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGVzID0gX3R5cGVJcy5hcnJheShzY2hlbWEudHlwZSkgPyBzY2hlbWEudHlwZSA6IFtzY2hlbWEudHlwZV07XG4gICAgICB2YXIgdHlwZUlzVmFsaWQgPSB0eXBlcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBfc2ltcGxlVHlwZSh0eXBlLCBjYW5kaWRhdGUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXR5cGVJc1ZhbGlkKSB7XG4gICAgICAgIHR5cGVzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0eXBlb2YgdCA9PT0gJ2Z1bmN0aW9uJyA/ICdhbiBpbnN0YW5jZSBvZiAnICsgdC5uYW1lIDogdDsgfSk7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlICcgKyB0eXBlcy5qb2luKCcgb3IgJykgKyAnLCBidXQgaXMgJyArIF9yZWFsVHlwZShjYW5kaWRhdGUpLCBudWxsLCAndHlwZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5pcXVlbmVzczogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS51bmlxdWVuZXNzID09PSAnc3RyaW5nJykgeyBzY2hlbWEudW5pcXVlbmVzcyA9IChzY2hlbWEudW5pcXVlbmVzcyA9PT0gJ3RydWUnKTsgfVxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEudW5pcXVlbmVzcyAhPT0gJ2Jvb2xlYW4nIHx8IHNjaGVtYS51bmlxdWVuZXNzID09PSBmYWxzZSB8fCAoIV90eXBlSXMuYXJyYXkoY2FuZGlkYXRlKSAmJiB0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlcG9ydGVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVwb3J0ZWQuaW5kZXhPZihjYW5kaWRhdGVbaV0pID49IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhlcyA9IGdldEluZGV4ZXMoY2FuZGlkYXRlLCBjYW5kaWRhdGVbaV0pO1xuICAgICAgICBpZiAoaW5kZXhlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmVwb3J0ZWQucHVzaChjYW5kaWRhdGVbaV0pO1xuICAgICAgICAgIHRoaXMucmVwb3J0KCdoYXMgdmFsdWUgWycgKyBjYW5kaWRhdGVbaV0gKyAnXSBtb3JlIHRoYW4gb25jZSBhdCBpbmRleGVzIFsnICsgaW5kZXhlcy5qb2luKCcsICcpICsgJ10nLCBudWxsLCAndW5pcXVlbmVzcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXR0ZXJuOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciByZWdleHMgPSBzY2hlbWEucGF0dGVybjtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgaWYgKCFfdHlwZUlzLmFycmF5KHJlZ2V4cykpIHtcbiAgICAgICAgcmVnZXhzID0gW3JlZ2V4c107XG4gICAgICB9XG4gICAgICByZWdleHMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycgJiYgcmVnZXggaW4gX2Zvcm1hdHMpIHtcbiAgICAgICAgICByZWdleCA9IF9mb3JtYXRzW3JlZ2V4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnZXggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBpZiAocmVnZXgudGVzdChjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHNlbGYucmVwb3J0KCdtdXN0IG1hdGNoIFsnICsgcmVnZXhzLmpvaW4oJyBvciAnKSArICddLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ3BhdHRlcm4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkRGF0ZTogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAoU3RyaW5nKHNjaGVtYS52YWxpZERhdGUpID09PSAndHJ1ZScgJiYgY2FuZGlkYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiBpc05hTihjYW5kaWRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBhIHZhbGlkIGRhdGUnLCBudWxsLCAndmFsaWREYXRlJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtaW5MZW5ndGg6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnICYmICFfdHlwZUlzLmFycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1pbkxlbmd0aCA9IE51bWJlcihzY2hlbWEubWluTGVuZ3RoKTtcbiAgICAgIGlmIChpc05hTihtaW5MZW5ndGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGxvbmdlciB0aGFuICcgKyBtaW5MZW5ndGggKyAnIGVsZW1lbnRzLCBidXQgaXQgaGFzICcgKyBjYW5kaWRhdGUubGVuZ3RoLCBudWxsLCAnbWluTGVuZ3RoJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXhMZW5ndGg6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnICYmICFfdHlwZUlzLmFycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1heExlbmd0aCA9IE51bWJlcihzY2hlbWEubWF4TGVuZ3RoKTtcbiAgICAgIGlmIChpc05hTihtYXhMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIHNob3J0ZXIgdGhhbiAnICsgbWF4TGVuZ3RoICsgJyBlbGVtZW50cywgYnV0IGl0IGhhcyAnICsgY2FuZGlkYXRlLmxlbmd0aCwgbnVsbCwgJ21heExlbmd0aCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhhY3RMZW5ndGg6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnICYmICFfdHlwZUlzLmFycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGV4YWN0TGVuZ3RoID0gTnVtYmVyKHNjaGVtYS5leGFjdExlbmd0aCk7XG4gICAgICBpZiAoaXNOYU4oZXhhY3RMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoICE9PSBleGFjdExlbmd0aCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBoYXZlIGV4YWN0bHkgJyArIGV4YWN0TGVuZ3RoICsgJyBlbGVtZW50cywgYnV0IGl0IGhhdmUgJyArIGNhbmRpZGF0ZS5sZW5ndGgsIG51bGwsICdleGFjdExlbmd0aCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbHQ6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgdmFyIGxpbWl0ID0gTnVtYmVyKHNjaGVtYS5sdCk7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4obGltaXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUgPj0gbGltaXQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgbGVzcyB0aGFuICcgKyBsaW1pdCArICcsIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAnbHQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGx0ZTogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIoc2NoZW1hLmx0ZSk7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4obGltaXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUgPiBsaW1pdCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJyArIGxpbWl0ICsgJywgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdsdGUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGd0OiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlcihzY2hlbWEuZ3QpO1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGxpbWl0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlIDw9IGxpbWl0KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGdyZWF0ZXIgdGhhbiAnICsgbGltaXQgKyAnLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ2d0Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBndGU6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgdmFyIGxpbWl0ID0gTnVtYmVyKHNjaGVtYS5ndGUpO1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGxpbWl0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlIDwgbGltaXQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICcgKyBsaW1pdCArICcsIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAnZ3RlJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlcTogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaW1pdCA9IHNjaGVtYS5lcTtcbiAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInICYmIHR5cGVvZiBsaW1pdCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGxpbWl0ICE9PSAnYm9vbGVhbicgJiYgIV90eXBlSXMuYXJyYXkobGltaXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KGxpbWl0KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gbGltaXRbaV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgZXF1YWwgdG8gWycgKyBsaW1pdC5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICByZXR1cm4gJ1wiJyArIGwgKyAnXCInO1xuICAgICAgICB9KS5qb2luKCcgb3IgJykgKyAnXSwgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdlcScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZSAhPT0gbGltaXQpIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBlcXVhbCB0byBcIicgKyBsaW1pdCArICdcIiwgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdlcScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBuZTogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxpbWl0ID0gc2NoZW1hLm5lO1xuICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxpbWl0ICE9PSAnc3RyaW5nJyAmJiAhX3R5cGVJcy5hcnJheShsaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF90eXBlSXMuYXJyYXkobGltaXQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBsaW1pdFtpXSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnQoJ211c3Qgbm90IGJlIGVxdWFsIHRvIFwiJyArIGxpbWl0W2ldICsgJ1wiJywgbnVsbCwgJ25lJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBsaW1pdCkge1xuICAgICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IG5vdCBiZSBlcXVhbCB0byBcIicgKyBsaW1pdCArICdcIicsIG51bGwsICduZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtdWx0aXBsZU9mOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGNvbnN0IGRpdmlzb3IgPSBOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpO1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGRpdmlzb3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUgJSBkaXZpc29yICE9PSAwKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KGNhbmRpZGF0ZSArICcgaXMgbm90IGRpdmlzaWJsZSBieSAnICsgZGl2aXNvciwgbnVsbCwgJ211bHRpcGxlT2YnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNvbWVLZXlzOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdCkge1xuICAgICAgdmFyIF9rZXlzID0gc2NoZW1hLnNvbWVLZXlzO1xuICAgICAgaWYgKCFfdHlwZUlzLm9iamVjdChjYW5kaWRhdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkID0gX2tleXMuc29tZShmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAoYWN0aW9uIGluIGNhbmRpZGF0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBoYXZlIGF0IGxlYXN0IGtleSAnICsgX2tleXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuICdcIicgKyBpICsgJ1wiJztcbiAgICAgICAgfSkuam9pbignIG9yICcpLCBudWxsLCAnc29tZUtleXMnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0cmljdDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5zdHJpY3QgPT09ICdzdHJpbmcnKSB7IHNjaGVtYS5zdHJpY3QgPSAoc2NoZW1hLnN0cmljdCA9PT0gJ3RydWUnKTsgfVxuICAgICAgaWYgKHNjaGVtYS5zdHJpY3QgIT09IHRydWUgfHwgIV90eXBlSXMub2JqZWN0KGNhbmRpZGF0ZSkgfHwgIV90eXBlSXMub2JqZWN0KHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5wcm9wZXJ0aWVzWycqJ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpbnRydWRlciA9IE9iamVjdC5rZXlzKGNhbmRpZGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gKHR5cGVvZiBzY2hlbWEucHJvcGVydGllc1trZXldID09PSAndW5kZWZpbmVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW50cnVkZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBtc2cgPSAnc2hvdWxkIG5vdCBjb250YWlucyAnICsgKGludHJ1ZGVyLmxlbmd0aCA+IDEgPyAncHJvcGVydGllcycgOiAncHJvcGVydHknKSArXG4gICAgICAgICAgICAnIFsnICsgaW50cnVkZXIubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiAnXCInICsgaSArICdcIic7IH0pLmpvaW4oJywgJykgKyAnXSc7XG4gICAgICAgICAgc2VsZi5yZXBvcnQobXNnLCBudWxsLCAnc3RyaWN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGV4ZWM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0V4ZWMoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIChfdHlwZUlzLmFycmF5KHNjaGVtYS5leGVjKSA/IHNjaGVtYS5leGVjIDogW3NjaGVtYS5leGVjXSkuZm9yRWFjaChmdW5jdGlvbiAoZXhlYykge1xuICAgICAgICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBleGVjLmNhbGwoc2VsZiwgc2NoZW1hLCBjYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNQcm9wZXJ0aWVzKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShzY2hlbWEucHJvcGVydGllcyBpbnN0YW5jZW9mIE9iamVjdCkgfHwgIShjYW5kaWRhdGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzWycqJ10gIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgaW4gY2FuZGlkYXRlKSB7XG4gICAgICAgICAgaWYgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICB0aGlzLl92YWxpZGF0ZShwcm9wZXJ0aWVzWycqJ10sIGNhbmRpZGF0ZVtpXSk7XG4gICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICBpZiAoaSA9PT0gJyonKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZShwcm9wZXJ0aWVzW2ldLCBjYW5kaWRhdGVbaV0pO1xuICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVtczogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0l0ZW1zKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICEoY2FuZGlkYXRlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXRlbXMgPSBzY2hlbWEuaXRlbXM7XG4gICAgICB2YXIgaSwgbDtcbiAgICAgIC8vIElmIHByb3ZpZGVkIHNjaGVtYSBpcyBhbiBhcnJheVxuICAgICAgLy8gdGhlbiBjYWxsIHZhbGlkYXRlIGZvciBlYWNoIGNhc2VcbiAgICAgIC8vIGVsc2UgaXQgaXMgYW4gT2JqZWN0XG4gICAgICAvLyB0aGVuIGNhbGwgdmFsaWRhdGUgZm9yIGVhY2gga2V5XG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShpdGVtcykgJiYgX3R5cGVJcy5hcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9kZWVwZXJBcnJheShpKTtcbiAgICAgICAgICB0aGlzLl92YWxpZGF0ZShpdGVtc1tpXSwgY2FuZGlkYXRlW2ldKTtcbiAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjYW5kaWRhdGUpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhbmRpZGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgdGhpcy5fZGVlcGVyQXJyYXkoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKGl0ZW1zLCBjYW5kaWRhdGVba2V5XSk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBfYXN5bmNWYWxpZGF0aW9uQXR0cmlidXQgPSB7XG4gICAgYXN5bmNFeGVjOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBhc3luYy5lYWNoU2VyaWVzKF90eXBlSXMuYXJyYXkoc2NoZW1hLmV4ZWMpID8gc2NoZW1hLmV4ZWMgOiBbc2NoZW1hLmV4ZWNdLCBmdW5jdGlvbiAoZXhlYywgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAoZXhlYy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlYy5jYWxsKHNlbGYsIHNjaGVtYSwgY2FuZGlkYXRlLCBkb25lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlYy5jYWxsKHNlbGYsIHNjaGVtYSwgY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYy5uZXh0VGljayhkb25lKTtcbiAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGFzeW5jUHJvcGVydGllczogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCEoc2NoZW1hLnByb3BlcnRpZXMgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICFfdHlwZUlzLm9iamVjdChjYW5kaWRhdGUpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcztcbiAgICAgIGFzeW5jLnNlcmllcyhbXG4gICAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNbJyonXSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKGNhbmRpZGF0ZSksIGZ1bmN0aW9uIChpLCBkb25lKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3luYy5uZXh0VGljayhkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICAgIHNlbGYuX2FzeW5jVmFsaWRhdGUocHJvcGVydGllc1snKiddLCBjYW5kaWRhdGVbaV0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBuZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBmdW5jdGlvbiAoaSwgZG9uZSkge1xuICAgICAgICAgICAgaWYgKGkgPT09ICcqJykge1xuICAgICAgICAgICAgICByZXR1cm4gYXN5bmMubmV4dFRpY2soZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgICBzZWxmLl9hc3luY1ZhbGlkYXRlKHByb3BlcnRpZXNbaV0sIGNhbmRpZGF0ZVtpXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIG5leHQpO1xuICAgICAgICB9XG4gICAgICBdLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBhc3luY0l0ZW1zOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIShzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICEoY2FuZGlkYXRlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpdGVtcyA9IHNjaGVtYS5pdGVtcztcblxuICAgICAgaWYgKF90eXBlSXMuYXJyYXkoaXRlbXMpICYmIF90eXBlSXMuYXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICBhc3luYy50aW1lc1NlcmllcyhpdGVtcy5sZW5ndGgsIGZ1bmN0aW9uIChpLCBkb25lKSB7XG4gICAgICAgICAgc2VsZi5fZGVlcGVyQXJyYXkoaSk7XG4gICAgICAgICAgc2VsZi5fYXN5bmNWYWxpZGF0ZShpdGVtc1tpXSwgY2FuZGlkYXRlW2ldLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgIGRvbmUoZXJyLCByZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhjYW5kaWRhdGUpLCBmdW5jdGlvbiAoa2V5LCBkb25lKSB7XG4gICAgICAgICAgc2VsZi5fZGVlcGVyQXJyYXkoa2V5KTtcbiAgICAgICAgICBzZWxmLl9hc3luY1ZhbGlkYXRlKGl0ZW1zLCBjYW5kaWRhdGVba2V5XSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICBkb25lKGVyciwgcmVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBWYWxpZGF0aW9uIENsYXNzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaW5oZXJpdHMgZnJvbSBJbnNwZWN0aW9uIGNsYXNzIChhY3R1YWxseSB3ZSBqdXN0IGNhbGwgSW5zcGVjdGlvblxuICAvLyBjb25zdHJ1Y3RvciB3aXRoIHRoZSBuZXcgY29udGV4dCwgYmVjYXVzZSBpdHMgcHJvdG90eXBlIGlzIGVtcHR5XG4gIGZ1bmN0aW9uIFZhbGlkYXRpb24oc2NoZW1hLCBjdXN0b20pIHtcbiAgICBJbnNwZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNjaGVtYSwgX21lcmdlKFZhbGlkYXRpb24uY3VzdG9tLCBjdXN0b20pKTtcbiAgICB2YXIgX2Vycm9yID0gW107XG5cbiAgICB0aGlzLl9iYXNpY0ZpZWxkcyA9IE9iamVjdC5rZXlzKF92YWxpZGF0aW9uQXR0cmlidXQpO1xuICAgIHRoaXMuX2N1c3RvbUZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2N1c3RvbSk7XG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuXG4gICAgdGhpcy5yZXBvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgY29kZSwgcmVhc29uKSB7XG4gICAgICB2YXIgbmV3RXJyID0ge1xuICAgICAgICBjb2RlOiBjb2RlIHx8IHRoaXMudXNlckNvZGUgfHwgbnVsbCxcbiAgICAgICAgcmVhc29uOiByZWFzb24gfHwgJ3Vua25vd24nLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLnVzZXJFcnJvciB8fCBtZXNzYWdlIHx8ICdpcyBpbnZhbGlkJyxcbiAgICAgICAgcHJvcGVydHk6IHRoaXMudXNlckFsaWFzID8gKHRoaXMudXNlckFsaWFzICsgJyAoJyArIHRoaXMuX2R1bXBTdGFjaygpICsgJyknKSA6IHRoaXMuX2R1bXBTdGFjaygpXG4gICAgICB9O1xuICAgICAgX2Vycm9yLnB1c2gobmV3RXJyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBfZXJyb3IsXG4gICAgICAgIHZhbGlkOiBfZXJyb3IubGVuZ3RoID09PSAwLFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy52YWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdDYW5kaWRhdGUgaXMgdmFsaWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvci5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAnUHJvcGVydHkgJyArIGkucHJvcGVydHkgKyAnOiAnICsgaS5tZXNzYWdlO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBfZXh0ZW5kKFZhbGlkYXRpb24ucHJvdG90eXBlLCBfdmFsaWRhdGlvbkF0dHJpYnV0KTtcbiAgX2V4dGVuZChWYWxpZGF0aW9uLnByb3RvdHlwZSwgX2FzeW5jVmFsaWRhdGlvbkF0dHJpYnV0KTtcbiAgX2V4dGVuZChWYWxpZGF0aW9uLCBuZXcgQ3VzdG9taXNhYmxlKCkpO1xuXG4gIFZhbGlkYXRpb24ucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLm9yaWdpbiA9IGNhbmRpZGF0ZTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9hc3luY1ZhbGlkYXRlKHNlbGYuX3NjaGVtYSwgY2FuZGlkYXRlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgc2VsZi5vcmlnaW4gPSBudWxsO1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2VsZi5yZXN1bHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh0aGlzLl9zY2hlbWEsIGNhbmRpZGF0ZSkucmVzdWx0KCk7XG4gIH07XG5cbiAgVmFsaWRhdGlvbi5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXNlckNvZGUgPSBzY2hlbWEuY29kZSB8fCBudWxsO1xuICAgIHRoaXMudXNlckVycm9yID0gc2NoZW1hLmVycm9yIHx8IG51bGw7XG4gICAgdGhpcy51c2VyQWxpYXMgPSBzY2hlbWEuYWxpYXMgfHwgbnVsbDtcbiAgICB0aGlzLl9iYXNpY0ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoKGkgaW4gc2NoZW1hIHx8IGkgPT09ICdvcHRpb25hbCcpICYmIHR5cGVvZiB0aGlzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbaV0oc2NoZW1hLCBjYW5kaWRhdGUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX2N1c3RvbUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoaSBpbiBzY2hlbWEgJiYgdHlwZW9mIHRoaXMuX2N1c3RvbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9jdXN0b21baV0uY2FsbCh0aGlzLCBzY2hlbWEsIGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVmFsaWRhdGlvbi5wcm90b3R5cGUuX2FzeW5jVmFsaWRhdGUgPSBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudXNlckNvZGUgPSBzY2hlbWEuY29kZSB8fCBudWxsO1xuICAgIHRoaXMudXNlckVycm9yID0gc2NoZW1hLmVycm9yIHx8IG51bGw7XG4gICAgdGhpcy51c2VyQWxpYXMgPSBzY2hlbWEuYWxpYXMgfHwgbnVsbDtcblxuICAgIGFzeW5jLnNlcmllcyhbXG4gICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKF92YWxpZGF0aW9uQXR0cmlidXQpLCBmdW5jdGlvbiAoaSwgZG9uZSkge1xuICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgoaSBpbiBzY2hlbWEgfHwgaSA9PT0gJ29wdGlvbmFsJykgJiYgdHlwZW9mIHNlbGZbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGZbaV0ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmW2ldKHNjaGVtYSwgY2FuZGlkYXRlLCBkb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmW2ldKHNjaGVtYSwgY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbmV4dCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhPYmplY3Qua2V5cyhzZWxmLl9jdXN0b20pLCBmdW5jdGlvbiAoaSwgZG9uZSkge1xuICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2VsZi5fY3VzdG9tW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLl9jdXN0b21baV0ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9jdXN0b21baV0uY2FsbChzZWxmLCBzY2hlbWEsIGNhbmRpZGF0ZSwgZG9uZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5fY3VzdG9tW2ldLmNhbGwoc2VsZiwgc2NoZW1hLCBjYW5kaWRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBuZXh0KTtcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLy8gU2FuaXRpemF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZnVuY3Rpb25zIGNhbGxlZCBieSBfc2FuaXRpemF0aW9uLnR5cGUgbWV0aG9kLlxuICB2YXIgX2ZvcmNlVHlwZSA9IHtcbiAgICBudW1iZXI6IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIHZhciBuO1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH0gZWxzZSBpZiAocG9zdCA9PT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiBzY2hlbWEuZGVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbiA9IHBhcnNlRmxvYXQocG9zdC5yZXBsYWNlKC8sL2csICcuJykucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgICBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocG9zdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICtwb3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICB2YXIgbjtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ251bWJlcicgJiYgcG9zdCAlIDEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9IGVsc2UgaWYgKHBvc3QgPT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmRlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hLmRlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG4gPSBwYXJzZUludChwb3N0LnJlcGxhY2UoLyAvZywgJycpLCAxMCk7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcG9zdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBvc3QsIDEwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBvc3QgPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAocG9zdCkgeyByZXR1cm4gMTsgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAocG9zdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICtwb3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBwb3N0ID09PSAnbnVtYmVyJyB8fCBwb3N0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gcG9zdC50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZUlzLmFycmF5KHBvc3QpKSB7XG4gICAgICAgIC8vIElmIHVzZXIgYXV0aG9yaXplIGFycmF5IGFuZCBzdHJpbmdzLi4uXG4gICAgICAgIGlmIChzY2hlbWEuaXRlbXMgfHwgc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zdC5qb2luKFN0cmluZyhzY2hlbWEuam9pbldpdGggfHwgJywnKSk7XG4gICAgICB9IGVsc2UgaWYgKHBvc3QgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgLy8gSWYgdXNlciBhdXRob3JpemUgb2JqZWN0cyBhbnMgc3RyaW5ncy4uLlxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zIHx8IHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBvc3QpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3N0cmluZycgJiYgcG9zdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGRhdGU6IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIGlmIChwb3N0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkID0gbmV3IERhdGUocG9zdCk7XG4gICAgICAgIGlmICghaXNOYU4oZC5nZXRUaW1lKCkpKSB7IC8vIGlmIHZhbGlkIGRhdGVcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBib29sZWFuOiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3N0cmluZycgJiYgcG9zdC50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gISFwb3N0O1xuICAgIH0sXG4gICAgb2JqZWN0OiBmdW5jdGlvbiAocG9zdCwgc2NoZW1hKSB7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgIT09ICdzdHJpbmcnIHx8IF90eXBlSXMub2JqZWN0KHBvc3QpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocG9zdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXJyYXk6IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KHBvc3QpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHBvc3Quc3Vic3RyaW5nKDAsIDEpID09PSAnWycgJiYgcG9zdC5zbGljZSgtMSkgPT09ICddJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShwb3N0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3Quc3BsaXQoU3RyaW5nKHNjaGVtYS5zcGxpdFdpdGggfHwgJywnKSk7XG4gICAgICB9XG4gICAgICBpZiAoIV90eXBlSXMuYXJyYXkocG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIFtwb3N0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX2FwcGx5UnVsZXMgPSB7XG4gICAgdXBwZXI6IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgICByZXR1cm4gcG9zdC50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgbG93ZXI6IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgICByZXR1cm4gcG9zdC50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgdGl0bGU6IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgICAvLyBGaXggYnkgc2ViIChyZXBsYWNlIFxcd1xcUyogYnkgXFxTKiA9PiBleGVtcGxlIDogY291Y291IMOnYSB2YSlcbiAgICAgIHJldHVybiBwb3N0LnJlcGxhY2UoL1xcUyovZywgZnVuY3Rpb24gKHR4dCkge1xuICAgICAgICByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjYXBpdGFsaXplOiBmdW5jdGlvbiAocG9zdCkge1xuICAgICAgcmV0dXJuIHBvc3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwb3N0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgdWNmaXJzdDogZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgIHJldHVybiBwb3N0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcG9zdC5zdWJzdHIoMSk7XG4gICAgfSxcbiAgICB0cmltOiBmdW5jdGlvbiAocG9zdCkge1xuICAgICAgcmV0dXJuIHBvc3QudHJpbSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFdmVyeSBmdW5jdGlvbiByZXR1cm4gdGhlIGZ1dHVyZSB2YWx1ZSBvZiBlYWNoIHByb3BlcnR5LiBUaGVyZWZvcmUgeW91XG4gIC8vIGhhdmUgdG8gcmV0dXJuIHBvc3QgZXZlbiBpZiB5b3UgZG8gbm90IGNoYW5nZSBpdHMgdmFsdWVcbiAgdmFyIF9zYW5pdGl6YXRpb25BdHRyaWJ1dCA9IHtcbiAgICBzdHJpY3Q6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnN0cmljdCA9PT0gJ3N0cmluZycpIHsgc2NoZW1hLnN0cmljdCA9IChzY2hlbWEuc3RyaWN0ID09PSAndHJ1ZScpOyB9XG4gICAgICBpZiAoc2NoZW1hLnN0cmljdCAhPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmICghX3R5cGVJcy5vYmplY3Qoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKCFfdHlwZUlzLm9iamVjdChwb3N0KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKHBvc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIG9wdGlvbmFsOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICB2YXIgb3B0ID0gdHlwZW9mIHNjaGVtYS5vcHRpb25hbCA9PT0gJ2Jvb2xlYW4nID8gc2NoZW1hLm9wdGlvbmFsIDogKHNjaGVtYS5vcHRpb25hbCAhPT0gJ2ZhbHNlJyk7IC8vIERlZmF1bHQ6IHRydWVcbiAgICAgIGlmIChvcHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBvc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgIGlmIChzY2hlbWEuZGVmID09PSBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYS5kZWY7XG4gICAgfSxcbiAgICB0eXBlOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICAvLyBpZiAoX3R5cGVJc1snb2JqZWN0J10ocG9zdCkgfHwgX3R5cGVJcy5hcnJheShwb3N0KSkge1xuICAgICAgLy8gICByZXR1cm4gcG9zdDtcbiAgICAgIC8vIH1cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnR5cGUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBfZm9yY2VUeXBlW3NjaGVtYS50eXBlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBuO1xuICAgICAgdmFyIG9wdCA9IHR5cGVvZiBzY2hlbWEub3B0aW9uYWwgPT09ICdib29sZWFuJyA/IHNjaGVtYS5vcHRpb25hbCA6IHRydWU7XG4gICAgICBpZiAodHlwZW9mIF9mb3JjZVR5cGVbc2NoZW1hLnR5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG4gPSBfZm9yY2VUeXBlW3NjaGVtYS50eXBlXShwb3N0LCBzY2hlbWEpO1xuICAgICAgICBpZiAoKG4gPT09IG51bGwgJiYgIW9wdCkgfHwgKCFuICYmIGlzTmFOKG4pKSB8fCAobiA9PT0gbnVsbCAmJiBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgbiA9IHNjaGVtYS5kZWY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIW9wdCkge1xuICAgICAgICBuID0gc2NoZW1hLmRlZjtcbiAgICAgIH1cbiAgICAgIGlmICgobiAhPSBudWxsIHx8ICh0eXBlb2Ygc2NoZW1hLmRlZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2NoZW1hLmRlZiA9PT0gbikpICYmIG4gIT09IHBvc3QpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIHJ1bGVzOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICB2YXIgcnVsZXMgPSBzY2hlbWEucnVsZXM7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgIT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgcnVsZXMgIT09ICdzdHJpbmcnICYmICFfdHlwZUlzLmFycmF5KHJ1bGVzKSkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIChfdHlwZUlzLmFycmF5KHJ1bGVzKSA/IHJ1bGVzIDogW3J1bGVzXSkuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBpZiAodHlwZW9mIF9hcHBseVJ1bGVzW3J1bGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcG9zdCA9IF9hcHBseVJ1bGVzW3J1bGVdKHBvc3QpO1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgbWluOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICB2YXIgcG9zdFRlc3QgPSBOdW1iZXIocG9zdCk7XG4gICAgICBpZiAoaXNOYU4ocG9zdFRlc3QpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIG1pbiA9IE51bWJlcihzY2hlbWEubWluKTtcbiAgICAgIGlmIChpc05hTihtaW4pKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKHBvc3RUZXN0IDwgbWluKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIG1heDogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgdmFyIHBvc3RUZXN0ID0gTnVtYmVyKHBvc3QpO1xuICAgICAgaWYgKGlzTmFOKHBvc3RUZXN0KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBtYXggPSBOdW1iZXIoc2NoZW1hLm1heCk7XG4gICAgICBpZiAoaXNOYU4obWF4KSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0VGVzdCA+IG1heCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBtaW5MZW5ndGg6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlcihzY2hlbWEubWluTGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCAhPT0gJ3N0cmluZycgfHwgaXNOYU4obGltaXQpIHx8IGxpbWl0IDwgMCkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHZhciBnYXAgPSBsaW1pdCAtIHBvc3QubGVuZ3RoO1xuICAgICAgaWYgKGdhcCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYXA7IGkrKykge1xuICAgICAgICAgIHN0ciArPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgICAgcmV0dXJuIHBvc3QgKyBzdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIG1heExlbmd0aDogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgdmFyIGxpbWl0ID0gTnVtYmVyKHNjaGVtYS5tYXhMZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ICE9PSAnc3RyaW5nJyB8fCBpc05hTihsaW1pdCkgfHwgbGltaXQgPCAwKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKHBvc3QubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgICAgcmV0dXJuIHBvc3Quc2xpY2UoMCwgbGltaXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY1Byb3BlcnRpZXMoc2NoZW1hLCBwb3N0LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIXBvc3QgfHwgdHlwZW9mIHBvc3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcztcbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcGVydGllc1snKiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmb3IgKGkgaW4gcG9zdCkge1xuICAgICAgICAgIGlmIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgdG1wID0gdGhpcy5fc2FuaXRpemUocHJvcGVydGllc1snKiddLCBwb3N0W2ldKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRtcCAhPT0gJ3VuZGVmaW5lZCcgfHwgJ2V4ZWMnIGluIHByb3BlcnRpZXNbJyonXSkge1xuICAgICAgICAgICAgcG9zdFtpXSA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICBpZiAoaSAhPT0gJyonKSB7XG4gICAgICAgICAgdGhpcy5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgIHRtcCA9IHRoaXMuX3Nhbml0aXplKHByb3BlcnRpZXNbaV0sIHBvc3RbaV0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG1wICE9PSAndW5kZWZpbmVkJyB8fCAnZXhlYycgaW4gcHJvcGVydGllc1tpXSkge1xuICAgICAgICAgICAgcG9zdFtpXSA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIGl0ZW1zOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0l0ZW1zKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoc2NoZW1hLml0ZW1zIGluc3RhbmNlb2YgT2JqZWN0KSB8fCAhKHBvc3QgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShzY2hlbWEuaXRlbXMpICYmIF90eXBlSXMuYXJyYXkocG9zdCkpIHtcbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IHNjaGVtYS5pdGVtcy5sZW5ndGggPCBwb3N0Lmxlbmd0aCA/IHNjaGVtYS5pdGVtcy5sZW5ndGggOiBwb3N0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fZGVlcGVyQXJyYXkoaSk7XG4gICAgICAgICAgcG9zdFtpXSA9IHRoaXMuX3Nhbml0aXplKHNjaGVtYS5pdGVtc1tpXSwgcG9zdFtpXSk7XG4gICAgICAgICAgdGhpcy5fYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gcG9zdCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocG9zdCwgaSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZXBlckFycmF5KGkpO1xuICAgICAgICAgICAgcG9zdFtpXSA9IHRoaXMuX3Nhbml0aXplKHNjaGVtYS5pdGVtcywgcG9zdFtpXSk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIGV4ZWM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jRXhlYyhzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHZhciBleGVjcyA9IF90eXBlSXMuYXJyYXkoc2NoZW1hLmV4ZWMpID8gc2NoZW1hLmV4ZWMgOiBbc2NoZW1hLmV4ZWNdO1xuXG4gICAgICBleGVjcy5mb3JFYWNoKGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHBvc3QgPSBleGVjLmNhbGwodGhpcywgc2NoZW1hLCBwb3N0KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9hc3luY1Nhbml0aXphdGlvbkF0dHJpYnV0ID0ge1xuICAgIGFzeW5jRXhlYzogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBleGVjcyA9IF90eXBlSXMuYXJyYXkoc2NoZW1hLmV4ZWMpID8gc2NoZW1hLmV4ZWMgOiBbc2NoZW1hLmV4ZWNdO1xuXG4gICAgICBhc3luYy5lYWNoU2VyaWVzKGV4ZWNzLCBmdW5jdGlvbiAoZXhlYywgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAoZXhlYy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlYy5jYWxsKHNlbGYsIHNjaGVtYSwgcG9zdCwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBvc3QgPSByZXM7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3N0ID0gZXhlYy5jYWxsKHNlbGYsIHNjaGVtYSwgcG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHBvc3QpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhc3luY1Byb3BlcnRpZXM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXBvc3QgfHwgdHlwZW9mIHBvc3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwb3N0KTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXM7XG5cbiAgICAgIGFzeW5jLnNlcmllcyhbXG4gICAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNbJyonXSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZ2xvYmluZyA9IHByb3BlcnRpZXNbJyonXTtcbiAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKHBvc3QpLCBmdW5jdGlvbiAoaSwgbmV4dCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgICAgc2VsZi5fYXN5bmNTYW5pdGl6ZShnbG9iaW5nLCBwb3N0W2ldLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikgeyAvKiBFcnJvciBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaGVyZSAqLyB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHBvc3RbaV0gPSByZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBuZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBmdW5jdGlvbiAoaSwgbmV4dCkge1xuICAgICAgICAgICAgaWYgKGkgPT09ICcqJykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgICAgc2VsZi5fYXN5bmNTYW5pdGl6ZShwcm9wZXJ0aWVzW2ldLCBwb3N0W2ldLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcG9zdFtpXSA9IHJlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIG5leHQpO1xuICAgICAgICB9XG4gICAgICBdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHBvc3QpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhc3luY0l0ZW1zOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgICAgaWYgKCEoc2NoZW1hLml0ZW1zIGluc3RhbmNlb2YgT2JqZWN0KSB8fCAhKHBvc3QgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwb3N0KTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KGl0ZW1zKSAmJiBfdHlwZUlzLmFycmF5KHBvc3QpKSB7XG4gICAgICAgIHZhciBtaW5MZW5ndGggPSBpdGVtcy5sZW5ndGggPCBwb3N0Lmxlbmd0aCA/IGl0ZW1zLmxlbmd0aCA6IHBvc3QubGVuZ3RoO1xuICAgICAgICBhc3luYy50aW1lc1NlcmllcyhtaW5MZW5ndGgsIGZ1bmN0aW9uIChpLCBuZXh0KSB7XG4gICAgICAgICAgc2VsZi5fZGVlcGVyQXJyYXkoaSk7XG4gICAgICAgICAgc2VsZi5fYXN5bmNTYW5pdGl6ZShpdGVtc1tpXSwgcG9zdFtpXSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0W2ldID0gcmVzO1xuICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCBwb3N0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKHBvc3QpLCBmdW5jdGlvbiAoa2V5LCBuZXh0KSB7XG4gICAgICAgICAgc2VsZi5fZGVlcGVyQXJyYXkoa2V5KTtcbiAgICAgICAgICBzZWxmLl9hc3luY1Nhbml0aXplKGl0ZW1zLCBwb3N0W2tleV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdFtrZXldID0gcmVzO1xuICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCBwb3N0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2FuaXRpemF0aW9uIENsYXNzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGluaGVyaXRzIGZyb20gSW5zcGVjdGlvbiBjbGFzcyAoYWN0dWFsbHkgd2UganVzdCBjYWxsIEluc3BlY3Rpb25cbiAgLy8gY29uc3RydWN0b3Igd2l0aCB0aGUgbmV3IGNvbnRleHQsIGJlY2F1c2UgaXRzIHByb3RvdHlwZSBpcyBlbXB0eVxuICBmdW5jdGlvbiBTYW5pdGl6YXRpb24oc2NoZW1hLCBjdXN0b20pIHtcbiAgICBJbnNwZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNjaGVtYSwgX21lcmdlKFNhbml0aXphdGlvbi5jdXN0b20sIGN1c3RvbSkpO1xuICAgIHZhciBfcmVwb3J0aW5nID0gW107XG5cbiAgICB0aGlzLl9iYXNpY0ZpZWxkcyA9IE9iamVjdC5rZXlzKF9zYW5pdGl6YXRpb25BdHRyaWJ1dCk7XG4gICAgdGhpcy5fY3VzdG9tRmllbGRzID0gT2JqZWN0LmtleXModGhpcy5fY3VzdG9tKTtcbiAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG5cbiAgICB0aGlzLnJlcG9ydCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICB2YXIgbmV3Tm90ID0ge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8ICd3YXMgc2FuaXRpemVkJyxcbiAgICAgICAgcHJvcGVydHk6IHRoaXMudXNlckFsaWFzID8gKHRoaXMudXNlckFsaWFzICsgJyAoJyArIHRoaXMuX2R1bXBTdGFjaygpICsgJyknKSA6IHRoaXMuX2R1bXBTdGFjaygpXG4gICAgICB9O1xuICAgICAgaWYgKCFfcmVwb3J0aW5nLnNvbWUoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucHJvcGVydHkgPT09IG5ld05vdC5wcm9wZXJ0eTsgfSkpIHtcbiAgICAgICAgX3JlcG9ydGluZy5wdXNoKG5ld05vdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVzdWx0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIC8vIEZvciBvbGQgSUUuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICByZXBvcnRpbmc6IF9yZXBvcnRpbmcsXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcG9ydGluZy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAnUHJvcGVydHkgJyArIGkucHJvcGVydHkgKyAnICcgKyBpLm1lc3NhZ2U7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cbiAgICB9O1xuICB9XG5cbiAgX2V4dGVuZChTYW5pdGl6YXRpb24ucHJvdG90eXBlLCBfc2FuaXRpemF0aW9uQXR0cmlidXQpO1xuICBfZXh0ZW5kKFNhbml0aXphdGlvbi5wcm90b3R5cGUsIF9hc3luY1Nhbml0aXphdGlvbkF0dHJpYnV0KTtcbiAgX2V4dGVuZChTYW5pdGl6YXRpb24sIG5ldyBDdXN0b21pc2FibGUoKSk7XG5cbiAgU2FuaXRpemF0aW9uLnByb3RvdHlwZS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChwb3N0LCBjYWxsYmFjaykge1xuICAgIHRoaXMub3JpZ2luID0gcG9zdDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fYXN5bmNTYW5pdGl6ZSh0aGlzLl9zY2hlbWEsIHBvc3QsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgc2VsZi5vcmlnaW4gPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHNlbGYucmVzdWx0KGRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuX3Nhbml0aXplKHRoaXMuX3NjaGVtYSwgcG9zdCk7XG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnJlc3VsdChkYXRhKTtcbiAgfTtcblxuICBTYW5pdGl6YXRpb24ucHJvdG90eXBlLl9zYW5pdGl6ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICB0aGlzLnVzZXJBbGlhcyA9IHNjaGVtYS5hbGlhcyB8fCBudWxsO1xuICAgIHRoaXMuX2Jhc2ljRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmICgoaSBpbiBzY2hlbWEgfHwgaSA9PT0gJ29wdGlvbmFsJykgJiYgdHlwZW9mIHRoaXNbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zdCA9IHRoaXNbaV0oc2NoZW1hLCBwb3N0KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9jdXN0b21GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgaWYgKGkgaW4gc2NoZW1hICYmIHR5cGVvZiB0aGlzLl9jdXN0b21baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zdCA9IHRoaXMuX2N1c3RvbVtpXS5jYWxsKHRoaXMsIHNjaGVtYSwgcG9zdCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHBvc3Q7XG4gIH07XG5cbiAgU2FuaXRpemF0aW9uLnByb3RvdHlwZS5fYXN5bmNTYW5pdGl6ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudXNlckFsaWFzID0gc2NoZW1hLmFsaWFzIHx8IG51bGw7XG5cbiAgICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgYXN5bmMucmVkdWNlKHNlbGYuX2Jhc2ljRmllbGRzLCBwb3N0LCBmdW5jdGlvbiAodmFsdWUsIGksIG5leHQpIHtcbiAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKGkgaW4gc2NoZW1hIHx8IGkgPT09ICdvcHRpb25hbCcpICYmIHR5cGVvZiBzZWxmW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmW2ldLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZltpXShzY2hlbWEsIHZhbHVlLCBuZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZbaV0oc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0KG51bGwsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbmV4dCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGludGVyLCBuZXh0KSB7XG4gICAgICAgIGFzeW5jLnJlZHVjZShzZWxmLl9jdXN0b21GaWVsZHMsIGludGVyLCBmdW5jdGlvbiAodmFsdWUsIGksIG5leHQpIHtcbiAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzY2hlbWEgJiYgdHlwZW9mIHNlbGYuX2N1c3RvbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5fY3VzdG9tW2ldLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY3VzdG9tW2ldLmNhbGwoc2VsZiwgc2NoZW1hLCB2YWx1ZSwgbmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmLl9jdXN0b21baV0uY2FsbChzZWxmLCBzY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQobnVsbCwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBuZXh0KTtcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIElOVF9NSU4gPSAtMjE0NzQ4MzY0ODtcbiAgdmFyIElOVF9NQVggPSAyMTQ3NDgzNjQ3O1xuXG4gIHZhciBfcmFuZCA9IHtcbiAgICBpbnQ6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArICgwIHwgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfSxcbiAgICBmbG9hdDogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbik7XG4gICAgfSxcbiAgICBib29sOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgPiAwLjUpO1xuICAgIH0sXG4gICAgY2hhcjogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmludChtaW4sIG1heCkpO1xuICAgIH0sXG4gICAgZnJvbUxpc3Q6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdFt0aGlzLmludCgwLCBsaXN0Lmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9mb3JtYXRTYW1wbGUgPSB7XG4gICAgJ2RhdGUtdGltZSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfSxcbiAgICBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XG4gICAgfSxcbiAgICB0aW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoe30sIHsgaG91cjEyOiBmYWxzZSB9KTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHZhciBzID0gJyMnO1xuICAgICAgaWYgKG1pbiA8IDEpIHtcbiAgICAgICAgbWluID0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3JhbmQuaW50KG1pbiwgbWF4KTsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9IF9yYW5kLmZyb21MaXN0KCcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIG51bWVyaWM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnJyArIF9yYW5kLmludCgwLCBJTlRfTUFYKTtcbiAgICB9LFxuICAgIGludGVnZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfcmFuZC5ib29sKCkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICctJyArIHRoaXMubnVtZXJpYygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubnVtZXJpYygpO1xuICAgIH0sXG4gICAgZGVjaW1hbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigpICsgJy4nICsgdGhpcy5udW1lcmljKCk7XG4gICAgfSxcbiAgICBhbHBoYTogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgaWYgKG1pbiA8IDEpIHtcbiAgICAgICAgbWluID0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3JhbmQuaW50KG1pbiwgbWF4KTsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9IF9yYW5kLmZyb21MaXN0KCdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIGFscGhhTnVtZXJpYzogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgaWYgKG1pbiA8IDEpIHtcbiAgICAgICAgbWluID0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3JhbmQuaW50KG1pbiwgbWF4KTsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9IF9yYW5kLmZyb21MaXN0KCdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcbiAgICBhbHBoYURhc2g6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIGlmIChtaW4gPCAxKSB7XG4gICAgICAgIG1pbiA9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9yYW5kLmludChtaW4sIG1heCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcyArPSBfcmFuZC5mcm9tTGlzdCgnXy1hYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5el8tQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfLTAxMjM0NTY3ODlfLScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcbiAgICBqYXZhc2NyaXB0OiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHZhciBzID0gX3JhbmQuZnJvbUxpc3QoJ18kYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpfJEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXyQnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3JhbmQuaW50KG1pbiwgbWF4IC0gMSk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcyArPSBfcmFuZC5mcm9tTGlzdCgnXyRhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5el8kQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfJDAxMjM0NTY3ODlfJCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9nZXRMaW1pdHMoc2NoZW1hKSB7XG4gICAgdmFyIG1pbiA9IElOVF9NSU47XG4gICAgdmFyIG1heCA9IElOVF9NQVg7XG5cbiAgICBpZiAoc2NoZW1hLmd0ZSAhPSBudWxsKSB7XG4gICAgICBtaW4gPSBzY2hlbWEuZ3RlO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hLmd0ICE9IG51bGwpIHtcbiAgICAgIG1pbiA9IHNjaGVtYS5ndCArIDE7XG4gICAgfVxuICAgIGlmIChzY2hlbWEubHRlICE9IG51bGwpIHtcbiAgICAgIG1heCA9IHNjaGVtYS5sdGU7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEubHQgIT0gbnVsbCkge1xuICAgICAgbWF4ID0gc2NoZW1hLmx0IC0gMTtcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRS5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXG4gICAgcmV0dXJuIHsgbWluOiBtaW4sIG1heDogbWF4IH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXG4gIH1cblxuICB2YXIgX3R5cGVHZW5lcmF0b3IgPSB7XG4gICAgc3RyaW5nOiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICBpZiAoc2NoZW1hLmVxICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5lcTtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gJyc7XG4gICAgICB2YXIgbWluTGVuZ3RoID0gc2NoZW1hLm1pbkxlbmd0aCAhPSBudWxsID8gc2NoZW1hLm1pbkxlbmd0aCA6IDA7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gc2NoZW1hLm1heExlbmd0aCAhPSBudWxsID8gc2NoZW1hLm1heExlbmd0aCA6IDMyO1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEucGF0dGVybiA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIF9mb3JtYXRTYW1wbGVbc2NoZW1hLnBhdHRlcm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfZm9ybWF0U2FtcGxlW3NjaGVtYS5wYXR0ZXJuXShtaW5MZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsID0gc2NoZW1hLmV4YWN0TGVuZ3RoICE9IG51bGwgPyBzY2hlbWEuZXhhY3RMZW5ndGggOiBfcmFuZC5pbnQobWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcyArPSBfcmFuZC5jaGFyKDMyLCAxMjYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcbiAgICBudW1iZXI6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIGlmIChzY2hlbWEuZXEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmVxO1xuICAgICAgfVxuICAgICAgdmFyIGxpbWl0ID0gX2dldExpbWl0cyhzY2hlbWEpO1xuICAgICAgdmFyIG4gPSBfcmFuZC5mbG9hdChsaW1pdC5taW4sIGxpbWl0Lm1heCk7XG4gICAgICBpZiAoc2NoZW1hLm5lICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5lID0gX3R5cGVJcy5hcnJheShzY2hlbWEubmUpID8gc2NoZW1hLm5lIDogW3NjaGVtYS5uZV07XG4gICAgICAgIHdoaWxlIChuZS5pbmRleE9mKG4pICE9PSAtMSkge1xuICAgICAgICAgIG4gPSBfcmFuZC5mbG9hdChsaW1pdC5taW4sIGxpbWl0Lm1heCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgaWYgKHNjaGVtYS5lcSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXE7XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgPSBfZ2V0TGltaXRzKHNjaGVtYSk7XG4gICAgICB2YXIgbiA9IF9yYW5kLmludChsaW1pdC5taW4sIGxpbWl0Lm1heCk7XG4gICAgICBpZiAoc2NoZW1hLm5lICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5lID0gX3R5cGVJcy5hcnJheShzY2hlbWEubmUpID8gc2NoZW1hLm5lIDogW3NjaGVtYS5uZV07XG4gICAgICAgIHdoaWxlIChuZS5pbmRleE9mKG4pICE9PSAtMSkge1xuICAgICAgICAgIG4gPSBfcmFuZC5pbnQobGltaXQubWluLCBsaW1pdC5tYXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIGJvb2xlYW46IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIGlmIChzY2hlbWEuZXEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmVxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yYW5kLmJvb2woKTtcbiAgICB9LFxuICAgIG51bGw6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZGF0ZTogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgaWYgKHNjaGVtYS5lcSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9LFxuICAgIG9iamVjdDogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIHZhciBwcm9wID0gc2NoZW1hLnByb3BlcnRpZXMgfHwge307XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcCwga2V5KSkge1xuICAgICAgICAgIGlmIChwcm9wW2tleV0ub3B0aW9uYWwgPT09IHRydWUgJiYgX3JhbmQuYm9vbCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSAhPT0gJyonKSB7XG4gICAgICAgICAgICBvW2tleV0gPSB0aGlzLmdlbmVyYXRlKHByb3Bba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByayA9ICdfX3JhbmRvbV9rZXlfJztcbiAgICAgICAgICAgIHZhciByYW5kb21LZXkgPSByayArIDA7XG4gICAgICAgICAgICB2YXIgbiA9IF9yYW5kLmludCgxLCA5KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIShyYW5kb21LZXkgaW4gcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBvW3JhbmRvbUtleV0gPSB0aGlzLmdlbmVyYXRlKHByb3Bba2V5XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmFuZG9tS2V5ID0gcmsgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcbiAgICBhcnJheTogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zIHx8IHt9O1xuICAgICAgdmFyIG1pbkxlbmd0aCA9IHNjaGVtYS5taW5MZW5ndGggIT0gbnVsbCA/IHNjaGVtYS5taW5MZW5ndGggOiAwO1xuICAgICAgdmFyIG1heExlbmd0aCA9IHNjaGVtYS5tYXhMZW5ndGggIT0gbnVsbCA/IHNjaGVtYS5tYXhMZW5ndGggOiAxNjtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgdmFyIGNhbmRpZGF0ZTtcbiAgICAgIHZhciBzaXplO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KGl0ZW1zKSkge1xuICAgICAgICBzaXplID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICBpZiAoc2NoZW1hLmV4YWN0TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICBzaXplID0gc2NoZW1hLmV4YWN0TGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgICBzaXplID0gbWluTGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICBzaXplID0gbWF4TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNhbmRpZGF0ZSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB0eXBlID0gaXRlbXNbaV0udHlwZSB8fCAnYW55JztcbiAgICAgICAgICBpZiAoX3R5cGVJcy5hcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGVbX3JhbmQuaW50KDAsIHR5cGUubGVuZ3RoIC0gMSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW5kaWRhdGVbaV0gPSBzZWxmW3R5cGVdKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IHNjaGVtYS5leGFjdExlbmd0aCAhPSBudWxsID8gc2NoZW1hLmV4YWN0TGVuZ3RoIDogX3JhbmQuaW50KG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FuZGlkYXRlID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICB0eXBlID0gaXRlbXMudHlwZSB8fCAnYW55JztcbiAgICAgICAgaWYgKF90eXBlSXMuYXJyYXkodHlwZSkpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZVtfcmFuZC5pbnQoMCwgdHlwZS5sZW5ndGggLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIGNhbmRpZGF0ZVtpXSA9IHNlbGZbdHlwZV0oaXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgIH0sXG4gICAgYW55OiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMoX3R5cGVHZW5lcmF0b3IpO1xuICAgICAgdmFyIGkgPSBmaWVsZHNbX3JhbmQuaW50KDAsIGZpZWxkcy5sZW5ndGggLSAyKV07XG4gICAgICByZXR1cm4gdGhpc1tpXShzY2hlbWEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDYW5kaWRhdGVHZW5lcmF0b3IgQ2xhc3MgKFNpbmdsZXRvbikgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gQ2FuZGlkYXRlR2VuZXJhdG9yKCkge1xuICAgIC8vIE1heWJlIGV4dGVuZHMgSW5zcGVjdGlvbiBjbGFzcyB0b28gP1xuICB9XG5cbiAgX2V4dGVuZChDYW5kaWRhdGVHZW5lcmF0b3IucHJvdG90eXBlLCBfdHlwZUdlbmVyYXRvcik7XG5cbiAgdmFyIF9pbnN0YW5jZSA9IG51bGw7XG4gIENhbmRpZGF0ZUdlbmVyYXRvci5pbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIShfaW5zdGFuY2UgaW5zdGFuY2VvZiBDYW5kaWRhdGVHZW5lcmF0b3IpKSB7XG4gICAgICBfaW5zdGFuY2UgPSBuZXcgQ2FuZGlkYXRlR2VuZXJhdG9yKCk7XG4gICAgfVxuICAgIHJldHVybiBfaW5zdGFuY2U7XG4gIH07XG5cbiAgQ2FuZGlkYXRlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICB2YXIgdHlwZSA9IHNjaGVtYS50eXBlIHx8ICdhbnknO1xuICAgIGlmIChfdHlwZUlzLmFycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gdHlwZVtfcmFuZC5pbnQoMCwgdHlwZS5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzW3R5cGVdKHNjaGVtYSk7XG4gIH07XG5cbiAgLy8gRXhwb3J0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIFNjaGVtYUluc3BlY3RvciA9IHt9O1xuXG4gIC8vIGlmIHNlcnZlci1zaWRlIChub2RlLmpzKSBlbHNlIGNsaWVudC1zaWRlXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gU2NoZW1hSW5zcGVjdG9yO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5TY2hlbWFJbnNwZWN0b3IgPSBTY2hlbWFJbnNwZWN0b3I7XG4gIH1cblxuICBTY2hlbWFJbnNwZWN0b3IubmV3U2FuaXRpemF0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgY3VzdG9tKSB7XG4gICAgcmV0dXJuIG5ldyBTYW5pdGl6YXRpb24oc2NoZW1hLCBjdXN0b20pO1xuICB9O1xuXG4gIFNjaGVtYUluc3BlY3Rvci5uZXdWYWxpZGF0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgY3VzdG9tKSB7XG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uKHNjaGVtYSwgY3VzdG9tKTtcbiAgfTtcblxuICBTY2hlbWFJbnNwZWN0b3IuVmFsaWRhdGlvbiA9IFZhbGlkYXRpb247XG4gIFNjaGVtYUluc3BlY3Rvci5TYW5pdGl6YXRpb24gPSBTYW5pdGl6YXRpb247XG5cbiAgU2NoZW1hSW5zcGVjdG9yLnNhbml0aXplID0gZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY3VzdG9tLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBjdXN0b20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gY3VzdG9tO1xuICAgICAgY3VzdG9tID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTYW5pdGl6YXRpb24oc2NoZW1hLCBjdXN0b20pLnNhbml0aXplKHBvc3QsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBTY2hlbWFJbnNwZWN0b3IudmFsaWRhdGUgPSBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGN1c3RvbSwgY2FsbGJhY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgY3VzdG9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGN1c3RvbTtcbiAgICAgIGN1c3RvbSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbihzY2hlbWEsIGN1c3RvbSkudmFsaWRhdGUoY2FuZGlkYXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgU2NoZW1hSW5zcGVjdG9yLmdlbmVyYXRlID0gZnVuY3Rpb24gKHNjaGVtYSwgbikge1xuICAgIGlmICh0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciByID0gbmV3IEFycmF5KG4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcltpXSA9IENhbmRpZGF0ZUdlbmVyYXRvci5pbnN0YW5jZSgpLmdlbmVyYXRlKHNjaGVtYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgcmV0dXJuIENhbmRpZGF0ZUdlbmVyYXRvci5pbnN0YW5jZSgpLmdlbmVyYXRlKHNjaGVtYSk7XG4gIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js\n");

/***/ })

};
;